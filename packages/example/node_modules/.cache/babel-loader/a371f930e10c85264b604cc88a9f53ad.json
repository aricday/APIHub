{"ast":null,"code":"var async, booleanCrosses, booleanPointInPolygon, booleanWithin, bowser, compileDocumentSelector, compileSort, deg2rad, getDistanceFromLatLngInM, intersect, isLocalStorageSupported, pointInPolygon, polygonIntersection, processGeoIntersectsOperator, processNearOperator, _;\n\n_ = require('lodash');\nasync = require('async');\nbowser = require('bowser');\ncompileDocumentSelector = require('./selector').compileDocumentSelector;\ncompileSort = require('./selector').compileSort;\nbooleanPointInPolygon = require(\"@turf/boolean-point-in-polygon\")[\"default\"];\nintersect = require(\"@turf/intersect\")[\"default\"];\nbooleanCrosses = require(\"@turf/boolean-crosses\")[\"default\"];\nbooleanWithin = require(\"@turf/boolean-within\")[\"default\"];\n\nisLocalStorageSupported = function isLocalStorageSupported() {\n  var e;\n\n  if (!window.localStorage) {\n    return false;\n  }\n\n  try {\n    window.localStorage.setItem(\"test\", \"test\");\n    window.localStorage.removeItem(\"test\");\n    return true;\n  } catch (_error) {\n    e = _error;\n    return false;\n  }\n};\n\nexports.compileDocumentSelector = compileDocumentSelector;\n\nexports.autoselectLocalDb = function (options, success, error) {\n  var IndexedDb, LocalStorageDb, MemoryDb, WebSQLDb, browser, _ref;\n\n  IndexedDb = require('./IndexedDb');\n  WebSQLDb = require('./WebSQLDb');\n  LocalStorageDb = require('./LocalStorageDb');\n  MemoryDb = require('./MemoryDb');\n  browser = bowser.browser;\n\n  if (!isLocalStorageSupported()) {\n    return new MemoryDb(options, success);\n  }\n\n  if (window.cordova) {\n    if (((_ref = window.device) != null ? _ref.platform : void 0) === \"iOS\" && window.sqlitePlugin) {\n      console.log(\"Selecting WebSQLDb(sqlite) for Cordova\");\n      options.storage = 'sqlite';\n      return new WebSQLDb(options, success, error);\n    } else {\n      console.log(\"Selecting else WebSQLDb for Cordova\");\n      return new WebSQLDb(options, success, error);\n    }\n  }\n\n  if (browser.ios || browser.safari) {\n    return new IndexedDb(options, success, function (_this) {\n      return function (err) {\n        console.log(\"Failed to create IndexedDb: \" + (err ? err.message : void 0));\n        return new MemoryDb(options, success);\n      };\n    }(this));\n  }\n\n  if (browser.android || browser.chrome || browser.opera || browser.blackberry) {\n    console.log(\"Selecting WebSQLDb for browser\");\n    return new WebSQLDb(options, success, function (_this) {\n      return function (err) {\n        console.log(\"Failed to create WebSQLDb: \" + (err ? err.message : void 0));\n        return new IndexedDb(options, success, function (err) {\n          console.log(\"Failed to create IndexedDb: \" + (err ? err.message : void 0));\n          return new MemoryDb(options, success);\n        });\n      };\n    }(this));\n  }\n\n  if (browser.firefox && browser.version >= 16) {\n    console.log(\"Selecting IndexedDb for browser\");\n    return new IndexedDb(options, success, function (_this) {\n      return function (err) {\n        console.log(\"Failed to create IndexedDb: \" + (err ? err.message : void 0));\n        return new MemoryDb(options, success);\n      };\n    }(this));\n  }\n\n  console.log(\"Selecting LocalStorageDb for fallback\");\n  return new LocalStorageDb(options, success, error);\n};\n\nexports.migrateLocalDb = function (fromDb, toDb, success, error) {\n  var HybridDb, col, hybridDb, name, _ref;\n\n  HybridDb = require('./HybridDb');\n  hybridDb = new HybridDb(fromDb, toDb);\n  _ref = fromDb.collections;\n\n  for (name in _ref) {\n    col = _ref[name];\n\n    if (toDb[name]) {\n      hybridDb.addCollection(name);\n    }\n  }\n\n  return hybridDb.upload(success, error);\n};\n\nexports.cloneLocalDb = function (fromDb, toDb, success, error) {\n  var col, name, _ref;\n\n  _ref = fromDb.collections;\n\n  for (name in _ref) {\n    col = _ref[name];\n\n    if (!toDb[name]) {\n      toDb.addCollection(name);\n    }\n  }\n\n  return async.each(_.values(fromDb.collections), function (_this) {\n    return function (fromCol, cb) {\n      var toCol;\n      toCol = toDb[fromCol.name];\n      return fromCol.find({}).fetch(function (items) {\n        return toCol.seed(items, function () {\n          return fromCol.pendingUpserts(function (upserts) {\n            return toCol.upsert(_.pluck(upserts, \"doc\"), _.pluck(upserts, \"base\"), function () {\n              return fromCol.pendingRemoves(function (removes) {\n                return async.eachSeries(removes, function (remove, cb2) {\n                  return toCol.remove(remove, function () {\n                    return cb2();\n                  }, cb2);\n                }, cb);\n              }, cb);\n            }, cb);\n          }, cb);\n        }, cb);\n      }, cb);\n    };\n  }(this), function (_this) {\n    return function (err) {\n      if (err) {\n        return error(err);\n      }\n\n      return success();\n    };\n  }(this));\n};\n\nexports.cloneLocalCollection = function (fromCol, toCol, success, error) {\n  return fromCol.find({}).fetch(function (_this) {\n    return function (items) {\n      return toCol.seed(items, function () {\n        return fromCol.pendingUpserts(function (upserts) {\n          return toCol.upsert(_.pluck(upserts, \"doc\"), _.pluck(upserts, \"base\"), function () {\n            return fromCol.pendingRemoves(function (removes) {\n              return async.eachSeries(removes, function (remove, cb2) {\n                return toCol.remove(remove, function () {\n                  return cb2();\n                }, cb2);\n              }, function (err) {\n                if (err) {\n                  return error(err);\n                }\n\n                return success();\n              });\n            }, error);\n          }, error);\n        }, error);\n      }, error);\n    };\n  }(this), error);\n};\n\nexports.processFind = function (items, selector, options) {\n  var filtered;\n  filtered = _.filter(items, compileDocumentSelector(selector));\n  filtered = processNearOperator(selector, filtered);\n  filtered = processGeoIntersectsOperator(selector, filtered);\n\n  if (options && options.sort) {\n    filtered.sort(compileSort(options.sort));\n  }\n\n  if (options && options.skip) {\n    filtered = _.slice(filtered, options.skip);\n  }\n\n  if (options && options.limit) {\n    filtered = _.take(filtered, options.limit);\n  }\n\n  if (options && options.fields) {\n    filtered = exports.filterFields(filtered, options.fields);\n  }\n\n  return filtered;\n};\n\nexports.filterFields = function (items, fields) {\n  if (fields == null) {\n    fields = {};\n  }\n\n  if (_.keys(fields).length === 0) {\n    return items;\n  }\n\n  return _.map(items, function (item) {\n    var field, from, newItem, obj, path, pathElem, to, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _ref, _ref1, _ref2, _ref3;\n\n    newItem = {};\n\n    if (_.first(_.values(fields)) === 1) {\n      _ref = _.keys(fields).concat([\"_id\"]);\n\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        field = _ref[_i];\n        path = field.split(\".\");\n        obj = item;\n\n        for (_j = 0, _len1 = path.length; _j < _len1; _j++) {\n          pathElem = path[_j];\n\n          if (obj) {\n            obj = obj[pathElem];\n          }\n        }\n\n        if (obj == null) {\n          continue;\n        }\n\n        from = item;\n        to = newItem;\n        _ref1 = _.initial(path);\n\n        for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {\n          pathElem = _ref1[_k];\n          to[pathElem] = to[pathElem] || {};\n          to = to[pathElem];\n          from = from[pathElem];\n        }\n\n        to[_.last(path)] = from[_.last(path)];\n      }\n\n      return newItem;\n    } else {\n      item = _.cloneDeep(item);\n      _ref2 = _.keys(fields);\n\n      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {\n        field = _ref2[_l];\n        path = field.split(\".\");\n        obj = item;\n        _ref3 = _.initial(path);\n\n        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {\n          pathElem = _ref3[_m];\n\n          if (obj) {\n            obj = obj[pathElem];\n          }\n        }\n\n        if (obj == null) {\n          continue;\n        }\n\n        delete obj[_.last(path)];\n      }\n\n      return item;\n    }\n  });\n};\n\nexports.createUid = function () {\n  return 'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    var r, v;\n    r = Math.random() * 16 | 0;\n    v = c === 'x' ? r : r & 0x3 | 0x8;\n    return v.toString(16);\n  });\n};\n\nprocessNearOperator = function processNearOperator(selector, list) {\n  var distances, geo, key, value;\n\n  for (key in selector) {\n    value = selector[key];\n\n    if (value != null && value['$near']) {\n      geo = value['$near']['$geometry'];\n\n      if (geo.type !== 'Point') {\n        break;\n      }\n\n      list = _.filter(list, function (doc) {\n        return doc[key] && doc[key].type === 'Point';\n      });\n      distances = _.map(list, function (doc) {\n        return {\n          doc: doc,\n          distance: getDistanceFromLatLngInM(geo.coordinates[1], geo.coordinates[0], doc[key].coordinates[1], doc[key].coordinates[0])\n        };\n      });\n      distances = _.filter(distances, function (item) {\n        return item.distance >= 0;\n      });\n      distances = _.sortBy(distances, 'distance');\n\n      if (value['$near']['$maxDistance']) {\n        distances = _.filter(distances, function (item) {\n          return item.distance <= value['$near']['$maxDistance'];\n        });\n      }\n\n      list = _.pluck(distances, 'doc');\n    }\n  }\n\n  return list;\n};\n\npointInPolygon = function pointInPolygon(point, polygon) {\n  return booleanPointInPolygon(point, polygon);\n};\n\npolygonIntersection = function polygonIntersection(polygon1, polygon2) {\n  return intersect(polygon1, polygon2) != null;\n};\n\ngetDistanceFromLatLngInM = function getDistanceFromLatLngInM(lat1, lng1, lat2, lng2) {\n  var R, a, c, d, dLat, dLng;\n  R = 6370986;\n  dLat = deg2rad(lat2 - lat1);\n  dLng = deg2rad(lng2 - lng1);\n  a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(deg2rad(lat1)) * Math.cos(deg2rad(lat2)) * Math.sin(dLng / 2) * Math.sin(dLng / 2);\n  c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\n  d = R * c;\n  return d;\n};\n\ndeg2rad = function deg2rad(deg) {\n  return deg * (Math.PI / 180);\n};\n\nprocessGeoIntersectsOperator = function processGeoIntersectsOperator(selector, list) {\n  var geo, key, value;\n\n  for (key in selector) {\n    value = selector[key];\n\n    if (value != null && value['$geoIntersects']) {\n      geo = value['$geoIntersects']['$geometry'];\n\n      if (geo.type !== 'Polygon') {\n        break;\n      }\n\n      list = _.filter(list, function (doc) {\n        var line, lineGeo, _i, _len, _ref, _ref1;\n\n        if (!doc[key]) {\n          return false;\n        }\n\n        if (doc[key].type === 'Point') {\n          return pointInPolygon(doc[key], geo);\n        } else if ((_ref = doc[key].type) === \"Polygon\" || _ref === \"MultiPolygon\") {\n          return polygonIntersection(doc[key], geo);\n        } else if (doc[key].type === \"LineString\") {\n          return booleanCrosses(doc[key], geo) || booleanWithin(doc[key], geo);\n        } else if (doc[key].type === \"MultiLineString\") {\n          _ref1 = doc[key].coordinates;\n\n          for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n            line = _ref1[_i];\n            lineGeo = {\n              type: \"LineString\",\n              coordinates: line\n            };\n\n            if (booleanCrosses(lineGeo, geo) || booleanWithin(lineGeo, geo)) {\n              return true;\n            }\n          }\n\n          return false;\n        }\n      });\n    }\n  }\n\n  return list;\n};\n\nexports.regularizeUpsert = function (docs, bases, success, error) {\n  var item, items, _i, _len, _ref;\n\n  if (_.isFunction(bases)) {\n    _ref = [void 0, bases, success], bases = _ref[0], success = _ref[1], error = _ref[2];\n  }\n\n  if (!_.isArray(docs)) {\n    docs = [docs];\n    bases = [bases];\n  } else {\n    bases = bases || [];\n  }\n\n  items = _.map(docs, function (doc, i) {\n    return {\n      doc: doc,\n      base: i < bases.length ? bases[i] : void 0\n    };\n  });\n\n  for (_i = 0, _len = items.length; _i < _len; _i++) {\n    item = items[_i];\n\n    if (!item.doc._id) {\n      item.doc._id = exports.createUid();\n    }\n\n    if (item.base && !item.base._id) {\n      throw new Error(\"Base needs _id\");\n    }\n\n    if (item.base && item.base._id !== item.doc._id) {\n      throw new Error(\"Base needs same _id\");\n    }\n  }\n\n  return [items, success, error];\n};","map":null,"metadata":{},"sourceType":"script"}