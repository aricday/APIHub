{"ast":null,"code":"var Collection,\n    ReplicatingDb,\n    compileSort,\n    utils,\n    _,\n    __indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n};\n\n_ = require('lodash');\nutils = require('./utils');\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = ReplicatingDb = function () {\n  function ReplicatingDb(masterDb, replicaDb) {\n    this.collections = {};\n    this.masterDb = masterDb;\n    this.replicaDb = replicaDb;\n  }\n\n  ReplicatingDb.prototype.addCollection = function (name, success, error) {\n    var collection;\n    collection = new Collection(name, this.masterDb[name], this.replicaDb[name]);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  ReplicatingDb.prototype.removeCollection = function (name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  ReplicatingDb.prototype.getCollectionNames = function () {\n    return _.keys(this.collections);\n  };\n\n  return ReplicatingDb;\n}();\n\nCollection = function () {\n  function Collection(name, masterCol, replicaCol) {\n    this.name = name;\n    this.masterCol = masterCol;\n    this.replicaCol = replicaCol;\n  }\n\n  Collection.prototype.find = function (selector, options) {\n    return this.masterCol.find(selector, options);\n  };\n\n  Collection.prototype.findOne = function (selector, options, success, error) {\n    return this.masterCol.findOne(selector, options, success, error);\n  };\n\n  Collection.prototype.upsert = function (docs, bases, success, error) {\n    var items, _ref;\n\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    return this.masterCol.upsert(_.pluck(items, \"doc\"), _.pluck(items, \"base\"), function (_this) {\n      return function () {\n        return _this.replicaCol.upsert(_.pluck(items, \"doc\"), _.pluck(items, \"base\"), function (results) {\n          return success(docs);\n        }, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.remove = function (id, success, error) {\n    return this.masterCol.remove(id, function (_this) {\n      return function () {\n        return _this.replicaCol.remove(id, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.cache = function (docs, selector, options, success, error) {\n    var docsMap, sort;\n    docsMap = _.indexBy(docs, \"_id\");\n\n    if (options.sort) {\n      sort = compileSort(options.sort);\n    }\n\n    return this.masterCol.find(selector, options).fetch(function (_this) {\n      return function (results) {\n        var doc, performCaches, performUncaches, result, resultsMap, toCache, toUncache, _i, _j, _len, _len1, _ref, _ref1;\n\n        resultsMap = _.indexBy(results, \"_id\");\n        toCache = [];\n\n        for (_i = 0, _len = docs.length; _i < _len; _i++) {\n          doc = docs[_i];\n          result = resultsMap[doc._id];\n\n          if (options && options.exclude && (_ref = doc._id, __indexOf.call(options.exclude, _ref) >= 0)) {\n            continue;\n          }\n\n          if (!result) {\n            toCache.push(doc);\n            continue;\n          }\n\n          if (doc._rev && result._rev && doc._rev <= result._rev) {\n            continue;\n          }\n\n          if (!_.isEqual(doc, result)) {\n            toCache.push(doc);\n          }\n        }\n\n        toUncache = [];\n\n        for (_j = 0, _len1 = results.length; _j < _len1; _j++) {\n          result = results[_j];\n\n          if (options.limit && docs.length === options.limit) {\n            if (options.sort && sort(result, _.last(docs)) >= 0) {\n              continue;\n            }\n\n            if (!options.sort) {\n              continue;\n            }\n          }\n\n          if (options && options.exclude && (_ref1 = result._id, __indexOf.call(options.exclude, _ref1) >= 0)) {\n            continue;\n          }\n\n          if (!docsMap[result._id]) {\n            toUncache.push(result._id);\n          }\n        }\n\n        performCaches = function (next) {\n          if (toCache.length > 0) {\n            return _this.masterCol.cacheList(toCache, function () {\n              return _this.replicaCol.cacheList(toCache, function () {\n                return next();\n              }, error);\n            }, error);\n          } else {\n            return next();\n          }\n        };\n\n        performUncaches = function (next) {\n          if (toUncache.length > 0) {\n            return _this.masterCol.uncacheList(toUncache, function () {\n              return _this.replicaCol.uncacheList(toUncache, function () {\n                return next();\n              }, error);\n            }, error);\n          } else {\n            return next();\n          }\n        };\n\n        return performCaches(function () {\n          return performUncaches(function () {\n            if (success != null) {\n              success();\n            }\n          });\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function (success, error) {\n    return this.masterCol.pendingUpserts(success, error);\n  };\n\n  Collection.prototype.pendingRemoves = function (success, error) {\n    return this.masterCol.pendingRemoves(success, error);\n  };\n\n  Collection.prototype.resolveUpserts = function (upserts, success, error) {\n    return this.masterCol.resolveUpserts(upserts, function (_this) {\n      return function () {\n        return _this.replicaCol.resolveUpserts(upserts, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.resolveRemove = function (id, success, error) {\n    return this.masterCol.resolveRemove(id, function (_this) {\n      return function () {\n        return _this.replicaCol.resolveRemove(id, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.seed = function (docs, success, error) {\n    return this.masterCol.seed(docs, function (_this) {\n      return function () {\n        return _this.replicaCol.seed(docs, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.cacheOne = function (doc, success, error) {\n    return this.masterCol.cacheOne(doc, function (_this) {\n      return function () {\n        return _this.replicaCol.cacheOne(doc, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.cacheList = function (docs, success, error) {\n    return this.masterCol.cacheList(docs, function (_this) {\n      return function () {\n        return _this.replicaCol.cacheList(docs, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.uncache = function (selector, success, error) {\n    return this.masterCol.uncache(selector, function (_this) {\n      return function () {\n        return _this.replicaCol.uncache(selector, success, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.uncacheList = function (ids, success, error) {\n    return this.masterCol.uncacheList(ids, function (_this) {\n      return function () {\n        return _this.replicaCol.uncacheList(ids, success, error);\n      };\n    }(this), error);\n  };\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}