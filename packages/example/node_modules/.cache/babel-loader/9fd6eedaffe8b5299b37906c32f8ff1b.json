{"ast":null,"code":"var Collection,\n    WebSQLDb,\n    async,\n    compileSort,\n    doNothing,\n    processFind,\n    utils,\n    _,\n    __indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n};\n\n_ = require('lodash');\nasync = require('async');\nutils = require('./utils');\nprocessFind = require('./utils').processFind;\ncompileSort = require('./selector').compileSort;\n\ndoNothing = function doNothing() {};\n\nmodule.exports = WebSQLDb = function () {\n  function WebSQLDb(options, success, error) {\n    var checkV2, ex, migrateToV1, migrateToV2;\n    this.collections = {};\n\n    if (options.storage === 'sqlite' && window.sqlitePlugin) {\n      window.sqlitePlugin.openDatabase({\n        name: 'minimongo_' + options.namespace,\n        location: 'default'\n      }, function (_this) {\n        return function (sqliteDb) {\n          console.log(\"Database open successful\");\n          _this.db = sqliteDb;\n          console.log(\"Checking version\");\n\n          _this.db.executeSql(\"PRAGMA user_version\", [], function (rs) {\n            var version;\n            version = rs.rows.item(0).user_version;\n\n            if (version === 0) {\n              _this.db.transaction(function (tx) {\n                tx.executeSql('CREATE TABLE docs (\\ncol TEXT NOT NULL,\\nid TEXT NOT NULL,\\nstate TEXT NOT NULL,\\ndoc TEXT,\\nbase TEXT,\\nPRIMARY KEY (col, id));', [], doNothing, function (tx, err) {\n                  return error(err);\n                });\n                tx.executeSql(\"PRAGMA user_version = 2\", [], doNothing, function (tx, err) {\n                  return error(err);\n                });\n                return success(_this);\n              });\n            } else {\n              success(_this);\n            }\n          }, function (err) {\n            console.log(\"version check error :: \", JSON.stringify(err));\n            error(err);\n          });\n        };\n      }(this), function (err) {\n        console.log(\"Error opening databse :: \", JSON.stringify(err));\n        error(err);\n      });\n    } else {\n      try {\n        this.db = window.openDatabase('minimongo_' + options.namespace, '', 'Minimongo:' + options.namespace, 5 * 1024 * 1024);\n\n        if (!this.db) {\n          return error(new Error(\"Failed to create database\"));\n        }\n      } catch (_error) {\n        ex = _error;\n\n        if (error) {\n          error(ex);\n        }\n\n        return;\n      }\n    }\n\n    migrateToV1 = function migrateToV1(tx) {\n      return tx.executeSql('CREATE TABLE docs (\\n  col TEXT NOT NULL,\\n  id TEXT NOT NULL,\\n  state TEXT NOT NULL,\\n  doc TEXT,\\n  PRIMARY KEY (col, id));', [], doNothing, function (tx, err) {\n        return error(err);\n      });\n    };\n\n    migrateToV2 = function migrateToV2(tx) {\n      return tx.executeSql('ALTER TABLE docs ADD COLUMN base TEXT;', [], doNothing, function (tx, err) {\n        return error(err);\n      });\n    };\n\n    checkV2 = function (_this) {\n      return function () {\n        if (_this.db.version === \"1.0\") {\n          return _this.db.changeVersion(\"1.0\", \"2.0\", migrateToV2, error, function () {\n            if (success) {\n              return success(_this);\n            }\n          });\n        } else if (_this.db.version !== \"2.0\") {\n          return error(\"Unknown db version \" + _this.db.version);\n        } else {\n          if (success) {\n            return success(_this);\n          }\n        }\n      };\n    }(this);\n\n    if (!options.storage) {\n      if (!this.db.version) {\n        this.db.changeVersion(\"\", \"1.0\", migrateToV1, error, checkV2);\n      } else {\n        checkV2();\n      }\n    }\n\n    return this.db;\n  }\n\n  WebSQLDb.prototype.addCollection = function (name, success, error) {\n    var collection;\n    collection = new Collection(name, this.db);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success) {\n      return success();\n    }\n  };\n\n  WebSQLDb.prototype.removeCollection = function (name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    return this.db.transaction(function (tx) {\n      return tx.executeSql(\"DELETE FROM docs WHERE col = ?\", [name], success, function (tx, err) {\n        return error(err);\n      });\n    }, error);\n  };\n\n  WebSQLDb.prototype.getCollectionNames = function () {\n    return _.keys(this.collections);\n  };\n\n  return WebSQLDb;\n}();\n\nCollection = function () {\n  function Collection(name, db) {\n    this.name = name;\n    this.db = db;\n  }\n\n  Collection.prototype.find = function (selector, options) {\n    return {\n      fetch: function (_this) {\n        return function (success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      }(this)\n    };\n  };\n\n  Collection.prototype.findOne = function (selector, options, success, error) {\n    var _ref;\n\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n\n    return this.find(selector, options).fetch(function (results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function (selector, options, success, error) {\n    error = error || function () {};\n\n    return this.db.readTransaction(function (_this) {\n      return function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ?\", [_this.name], function (tx, results) {\n          var docs, i, row, _i, _ref;\n\n          docs = [];\n\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n\n            if (row.state !== \"removed\") {\n              docs.push(JSON.parse(row.doc));\n            }\n          }\n\n          if (success != null) {\n            return success(processFind(docs, selector, options));\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.upsert = function (docs, bases, success, error) {\n    var items, _ref;\n\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        var ids;\n        ids = _.map(items, function (item) {\n          return item.doc._id;\n        });\n        bases = {};\n        return async.eachSeries(ids, function (id, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, id], function (tx2, results) {\n            var row;\n            tx = tx2;\n\n            if (results.rows.length > 0) {\n              row = results.rows.item(0);\n\n              if (row.state === \"upserted\") {\n                bases[row.id] = row.base ? JSON.parse(row.base) : null;\n              } else if (row.state === \"cached\") {\n                bases[row.id] = JSON.parse(row.doc);\n              }\n            }\n\n            return callback();\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function () {\n          var base, id, item, _i, _len, _results;\n\n          _results = [];\n\n          for (_i = 0, _len = items.length; _i < _len; _i++) {\n            item = items[_i];\n            id = item.doc._id;\n\n            if (item.base !== void 0) {\n              base = item.base;\n            } else if (bases[id]) {\n              base = bases[id];\n            } else {\n              base = null;\n            }\n\n            _results.push(tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc, base) VALUES (?, ?, ?, ?, ?)\", [_this.name, item.doc._id, \"upserted\", JSON.stringify(item.doc), JSON.stringify(base)], doNothing, function (tx, err) {\n              return error(err);\n            }));\n          }\n\n          return _results;\n        });\n      };\n    }(this), error, function () {\n      if (success) {\n        return success(docs);\n      }\n    });\n  };\n\n  Collection.prototype.remove = function (id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch(function (_this) {\n        return function (rows) {\n          return async.each(rows, function (row, cb) {\n            return _this.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        };\n      }(this), error);\n      return;\n    }\n\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, id], function (tx, results) {\n          if (results.rows.length > 0) {\n            return tx.executeSql('UPDATE docs SET state=\"removed\" WHERE col = ? AND id = ?', [_this.name, id], function () {\n              if (success) {\n                return success(id);\n              }\n            }, function (tx, err) {\n              return error(err);\n            });\n          } else {\n            return tx.executeSql(\"INSERT INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, id, \"removed\", JSON.stringify({\n              _id: id\n            })], function () {\n              if (success) {\n                return success(id);\n              }\n            }, function (tx, err) {\n              return error(err);\n            });\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.cache = function (docs, selector, options, success, error) {\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return async.eachSeries(docs, function (doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, doc._id], function (tx, results) {\n            var existing, _ref;\n\n            if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n              existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null;\n\n              if (options && options.exclude && (_ref = doc._id, __indexOf.call(options.exclude, _ref) >= 0)) {\n                callback();\n                return;\n              }\n\n              if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, doc._id, \"cached\", JSON.stringify(doc)], function () {\n                  return callback();\n                }, function (tx, err) {\n                  return error(err);\n                });\n              } else {\n                return callback();\n              }\n            } else {\n              return callback();\n            }\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          var docsMap, sort;\n\n          if (err) {\n            if (error) {\n              error(err);\n            }\n\n            return;\n          }\n\n          docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n\n          if (options.sort) {\n            sort = compileSort(options.sort);\n          }\n\n          return _this.find(selector, options).fetch(function (results) {\n            return _this.db.transaction(function (tx) {\n              return async.eachSeries(results, function (result, callback) {\n                return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, result._id], function (tx, rows) {\n                  var _ref;\n\n                  if (!docsMap[result._id] && rows.rows.length > 0 && rows.rows.item(0).state === \"cached\") {\n                    if (options && options.exclude && (_ref = result._id, __indexOf.call(options.exclude, _ref) >= 0)) {\n                      callback();\n                      return;\n                    }\n\n                    if (options.limit && docs.length === options.limit) {\n                      if (options.sort && sort(result, _.last(docs)) >= 0) {\n                        return callback();\n                      }\n\n                      if (!options.sort) {\n                        return callback();\n                      }\n                    }\n\n                    return tx.executeSql(\"DELETE FROM docs WHERE col = ? AND id = ?\", [_this.name, result._id], function () {\n                      return callback();\n                    }, function (tx, err) {\n                      return error(err);\n                    });\n                  } else {\n                    return callback();\n                  }\n                }, function (tx, err) {\n                  return error(err);\n                });\n              }, function (err) {\n                if (err != null) {\n                  if (error != null) {\n                    error(err);\n                  }\n\n                  return;\n                }\n\n                if (success != null) {\n                  return success();\n                }\n              });\n            }, error);\n          }, error);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function (success, error) {\n    error = error || function () {};\n\n    return this.db.readTransaction(function (_this) {\n      return function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this.name, \"upserted\"], function (tx, results) {\n          var docs, i, row, _i, _ref;\n\n          docs = [];\n\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            docs.push({\n              doc: JSON.parse(row.doc),\n              base: row.base ? JSON.parse(row.base) : null\n            });\n          }\n\n          if (success != null) {\n            return success(docs);\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.pendingRemoves = function (success, error) {\n    error = error || function () {};\n\n    return this.db.readTransaction(function (_this) {\n      return function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this.name, \"removed\"], function (tx, results) {\n          var docs, i, row, _i, _ref;\n\n          docs = [];\n\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            docs.push(JSON.parse(row.doc)._id);\n          }\n\n          if (success != null) {\n            return success(docs);\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.resolveUpserts = function (upserts, success, error) {\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return async.eachSeries(upserts, function (upsert, cb) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, upsert.doc._id], function (tx, results) {\n            if (results.rows.length > 0 && results.rows.item(0).state === \"upserted\") {\n              if (_.isEqual(JSON.parse(results.rows.item(0).doc), upsert.doc)) {\n                tx.executeSql('UPDATE docs SET state=\"cached\" WHERE col = ? AND id = ?', [_this.name, upsert.doc._id], doNothing, function (tx, err) {\n                  return error(err);\n                });\n                return cb();\n              } else {\n                tx.executeSql('UPDATE docs SET base=? WHERE col = ? AND id = ?', [JSON.stringify(upsert.doc), _this.name, upsert.doc._id], doNothing, function (tx, err) {\n                  return error(err);\n                });\n                return cb();\n              }\n            } else {\n              return cb();\n            }\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          if (err) {\n            return error(err);\n          }\n\n          if (success) {\n            return success();\n          }\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.resolveRemove = function (id, success, error) {\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return tx.executeSql('DELETE FROM docs WHERE state=\"removed\" AND col = ? AND id = ?', [_this.name, id], function () {\n          if (success) {\n            return success(id);\n          }\n        }, function (tx, err) {\n          return error(err);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.seed = function (docs, success, error) {\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return async.eachSeries(docs, function (doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, doc._id], function (tx, results) {\n            if (results.rows.length === 0) {\n              return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, doc._id, \"cached\", JSON.stringify(doc)], function () {\n                return callback();\n              }, function (tx, err) {\n                return error(err);\n              });\n            } else {\n              return callback();\n            }\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success();\n            }\n          }\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.cacheOne = function (doc, success, error) {\n    return this.cacheList([doc], success, error);\n  };\n\n  Collection.prototype.cacheList = function (docs, success, error) {\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return async.eachSeries(docs, function (doc, callback) {\n          return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND id = ?\", [_this.name, doc._id], function (tx, results) {\n            var existing;\n\n            if (results.rows.length === 0 || results.rows.item(0).state === \"cached\") {\n              existing = results.rows.length > 0 ? JSON.parse(results.rows.item(0).doc) : null;\n\n              if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n                return tx.executeSql(\"INSERT OR REPLACE INTO docs (col, id, state, doc) VALUES (?, ?, ?, ?)\", [_this.name, doc._id, \"cached\", JSON.stringify(doc)], function () {\n                  return callback();\n                }, function (tx, err) {\n                  return callback(err);\n                });\n              } else {\n                return callback();\n              }\n            } else {\n              return callback();\n            }\n          }, function (tx, err) {\n            return callback(err);\n          });\n        }, function (err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success(docs);\n            }\n          }\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.uncache = function (selector, success, error) {\n    var compiledSelector;\n    compiledSelector = utils.compileDocumentSelector(selector);\n\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return tx.executeSql(\"SELECT * FROM docs WHERE col = ? AND state = ?\", [_this.name, \"cached\"], function (tx, results) {\n          var doc, i, row, toRemove, _i, _ref;\n\n          toRemove = [];\n\n          for (i = _i = 0, _ref = results.rows.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n            row = results.rows.item(i);\n            doc = JSON.parse(row.doc);\n\n            if (compiledSelector(doc)) {\n              toRemove.push(doc._id);\n            }\n          }\n\n          return async.eachSeries(toRemove, function (id, callback) {\n            return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [_this.name, id], function () {\n              return callback();\n            }, function (tx, err) {\n              return error(err);\n            });\n          }, function (err) {\n            if (err) {\n              if (error) {\n                return error(err);\n              }\n            } else {\n              if (success) {\n                return success();\n              }\n            }\n          });\n        }, function (tx, err) {\n          return error(err);\n        });\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.uncacheList = function (ids, success, error) {\n    error = error || function () {};\n\n    return this.db.transaction(function (_this) {\n      return function (tx) {\n        return async.eachSeries(ids, function (id, callback) {\n          return tx.executeSql('DELETE FROM docs WHERE state=\"cached\" AND col = ? AND id = ?', [_this.name, id], function () {\n            return callback();\n          }, function (tx, err) {\n            return error(err);\n          });\n        }, function (err) {\n          if (err) {\n            if (error) {\n              return error(err);\n            }\n          } else {\n            if (success) {\n              return success();\n            }\n          }\n        });\n      };\n    }(this), error);\n  };\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}