{"ast":null,"code":"var Collection,\n    MemoryDb,\n    async,\n    compileSort,\n    processFind,\n    utils,\n    _,\n    __bind = function (fn, me) {\n  return function () {\n    return fn.apply(me, arguments);\n  };\n},\n    __indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n};\n\n_ = require('lodash');\nasync = require('async');\nutils = require('./utils');\nprocessFind = require('./utils').processFind;\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = MemoryDb = function () {\n  function MemoryDb(options, success) {\n    this.collections = {};\n    this.options = _.defaults(options, {\n      safety: \"clone\"\n    });\n\n    if (success) {\n      success(this);\n    }\n  }\n\n  MemoryDb.prototype.addCollection = function (name, success, error) {\n    var collection;\n    collection = new Collection(name, this.options);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  MemoryDb.prototype.removeCollection = function (name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  MemoryDb.prototype.getCollectionNames = function () {\n    return _.keys(this.collections);\n  };\n\n  return MemoryDb;\n}();\n\nCollection = function () {\n  function Collection(name, options) {\n    this._applySafety = __bind(this._applySafety, this);\n    this.name = name;\n    this.items = {};\n    this.upserts = {};\n    this.removes = {};\n    this.options = options || {};\n  }\n\n  Collection.prototype.find = function (selector, options) {\n    return {\n      fetch: function (_this) {\n        return function (success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      }(this)\n    };\n  };\n\n  Collection.prototype.findOne = function (selector, options, success, error) {\n    var _ref;\n\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n\n    return this.find(selector, options).fetch(function (_this) {\n      return function (results) {\n        if (success != null) {\n          return success(_this._applySafety(results.length > 0 ? results[0] : null));\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype._findFetch = function (selector, options, success, error) {\n    return setTimeout(function (_this) {\n      return function () {\n        var allItems, results;\n\n        if (selector && selector._id && _.isString(selector._id)) {\n          allItems = _.compact([_this.items[selector._id]]);\n        } else {\n          allItems = _.values(_this.items);\n        }\n\n        results = processFind(allItems, selector, options);\n\n        if (success != null) {\n          return success(_this._applySafety(results));\n        }\n      };\n    }(this), 0);\n  };\n\n  Collection.prototype._applySafety = function (items) {\n    if (!items) {\n      return items;\n    }\n\n    if (_.isArray(items)) {\n      return _.map(items, this._applySafety);\n    }\n\n    if (this.options.safety === \"clone\" || !this.options.safety) {\n      return JSON.parse(JSON.stringify(items));\n    }\n\n    if (this.options.safety === \"freeze\") {\n      Object.freeze(items);\n      return items;\n    }\n\n    throw new Error(\"Unsupported safety \" + this.options.safety);\n  };\n\n  Collection.prototype.upsert = function (docs, bases, success, error) {\n    var item, items, _i, _len, _ref;\n\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    items = JSON.parse(JSON.stringify(items));\n\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n\n      if (item.base === void 0) {\n        if (this.upserts[item.doc._id]) {\n          item.base = this.upserts[item.doc._id].base;\n        } else {\n          item.base = this.items[item.doc._id] || null;\n        }\n      }\n\n      this.items[item.doc._id] = item.doc;\n      this.upserts[item.doc._id] = item;\n    }\n\n    if (_.isArray(docs)) {\n      if (success) {\n        return success(this._applySafety(_.pluck(items, \"doc\")));\n      }\n    } else {\n      if (success) {\n        return success(this._applySafety(_.pluck(items, \"doc\")[0]));\n      }\n    }\n  };\n\n  Collection.prototype.remove = function (id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch(function (_this) {\n        return function (rows) {\n          return async.each(rows, function (row, cb) {\n            return _this.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        };\n      }(this), error);\n      return;\n    }\n\n    if (_.has(this.items, id)) {\n      this.removes[id] = this.items[id];\n      delete this.items[id];\n      delete this.upserts[id];\n    } else {\n      this.removes[id] = {\n        _id: id\n      };\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cache = function (docs, selector, options, success, error) {\n    var doc, docsMap, sort, _i, _len, _ref;\n\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n\n      if (options && options.exclude && (_ref = doc._id, __indexOf.call(options.exclude, _ref) >= 0)) {\n        continue;\n      }\n\n      this.cacheOne(doc);\n    }\n\n    docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n\n    if (options.sort) {\n      sort = compileSort(options.sort);\n    }\n\n    return this.find(selector, options).fetch(function (_this) {\n      return function (results) {\n        var result, _j, _len1, _ref1;\n\n        for (_j = 0, _len1 = results.length; _j < _len1; _j++) {\n          result = results[_j];\n\n          if (!docsMap[result._id] && !_.has(_this.upserts, result._id)) {\n            if (options.limit && docs.length === options.limit) {\n              if (options.sort && sort(result, _.last(docs)) >= 0) {\n                continue;\n              }\n\n              if (!options.sort) {\n                continue;\n              }\n            }\n\n            if (options && options.exclude && (_ref1 = result._id, __indexOf.call(options.exclude, _ref1) >= 0)) {\n              continue;\n            }\n\n            delete _this.items[result._id];\n          }\n        }\n\n        if (success != null) {\n          return success();\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function (success) {\n    return success(_.values(this.upserts));\n  };\n\n  Collection.prototype.pendingRemoves = function (success) {\n    return success(_.pluck(this.removes, \"_id\"));\n  };\n\n  Collection.prototype.resolveUpserts = function (upserts, success) {\n    var id, upsert, _i, _len;\n\n    for (_i = 0, _len = upserts.length; _i < _len; _i++) {\n      upsert = upserts[_i];\n      id = upsert.doc._id;\n\n      if (this.upserts[id]) {\n        if (_.isEqual(upsert.doc, this.upserts[id].doc)) {\n          delete this.upserts[id];\n        } else {\n          this.upserts[id].base = upsert.doc;\n        }\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.resolveRemove = function (id, success) {\n    delete this.removes[id];\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.seed = function (docs, success) {\n    var doc, _i, _len;\n\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n\n      if (!_.has(this.items, doc._id) && !_.has(this.removes, doc._id)) {\n        this.items[doc._id] = doc;\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cacheOne = function (doc, success, error) {\n    return this.cacheList([doc], success, error);\n  };\n\n  Collection.prototype.cacheList = function (docs, success) {\n    var doc, existing, _i, _len;\n\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n\n      if (!_.has(this.upserts, doc._id) && !_.has(this.removes, doc._id)) {\n        existing = this.items[doc._id];\n\n        if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n          this.items[doc._id] = doc;\n        }\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncache = function (selector, success, error) {\n    var compiledSelector, items;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    items = _.filter(_.values(this.items), function (_this) {\n      return function (item) {\n        return _this.upserts[item._id] != null || !compiledSelector(item);\n      };\n    }(this));\n    this.items = _.object(_.pluck(items, \"_id\"), items);\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncacheList = function (ids, success, error) {\n    var idIndex, items;\n    idIndex = _.indexBy(ids);\n    items = _.filter(_.values(this.items), function (_this) {\n      return function (item) {\n        return _this.upserts[item._id] != null || !idIndex[item._id];\n      };\n    }(this));\n    this.items = _.object(_.pluck(items, \"_id\"), items);\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}