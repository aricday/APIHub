{"ast":null,"code":"var Collection,\n    IDBStore,\n    IndexedDb,\n    async,\n    compileSort,\n    processFind,\n    utils,\n    _,\n    __indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n};\n\n_ = require('lodash');\nasync = require('async');\nIDBStore = require('idb-wrapper');\nutils = require('./utils');\nprocessFind = require('./utils').processFind;\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = IndexedDb = function () {\n  function IndexedDb(options, success, error) {\n    var ex;\n    this.collections = {};\n\n    try {\n      this.store = new IDBStore({\n        dbVersion: 1,\n        storeName: 'minimongo_' + options.namespace,\n        keyPath: ['col', 'doc._id'],\n        autoIncrement: false,\n        onStoreReady: function (_this) {\n          return function () {\n            if (success) {\n              return success(_this);\n            }\n          };\n        }(this),\n        onError: error,\n        indexes: [{\n          name: 'col',\n          keyPath: 'col',\n          unique: false,\n          multiEntry: false\n        }, {\n          name: 'col-state',\n          keyPath: ['col', 'state'],\n          unique: false,\n          multiEntry: false\n        }]\n      });\n    } catch (_error) {\n      ex = _error;\n\n      if (error) {\n        error(ex);\n      }\n\n      return;\n    }\n  }\n\n  IndexedDb.prototype.addCollection = function (name, success, error) {\n    var collection;\n    collection = new Collection(name, this.store);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success) {\n      return success();\n    }\n  };\n\n  IndexedDb.prototype.removeCollection = function (name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n    return this.store.query(function (_this) {\n      return function (matches) {\n        var keys;\n        keys = _.map(matches, function (m) {\n          return [m.col, m.doc._id];\n        });\n\n        if (keys.length > 0) {\n          return _this.store.removeBatch(keys, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    }(this), {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: name\n      }),\n      onError: error\n    });\n  };\n\n  IndexedDb.prototype.getCollectionNames = function () {\n    return _.keys(this.collections);\n  };\n\n  return IndexedDb;\n}();\n\nCollection = function () {\n  function Collection(name, store) {\n    this.name = name;\n    this.store = store;\n  }\n\n  Collection.prototype.find = function (selector, options) {\n    return {\n      fetch: function (_this) {\n        return function (success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      }(this)\n    };\n  };\n\n  Collection.prototype.findOne = function (selector, options, success, error) {\n    var _ref;\n\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n\n    return this.find(selector, options).fetch(function (results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function (selector, options, success, error) {\n    return this.store.query(function (matches) {\n      matches = _.filter(matches, function (m) {\n        return m.state !== \"removed\";\n      });\n\n      if (success != null) {\n        return success(processFind(_.pluck(matches, \"doc\"), selector, options));\n      }\n    }, {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.upsert = function (docs, bases, success, error) {\n    var items, keys, _ref;\n\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    keys = _.map(items, function (_this) {\n      return function (item) {\n        return [_this.name, item.doc._id];\n      };\n    }(this));\n    return this.store.getBatch(keys, function (_this) {\n      return function (records) {\n        var puts;\n        puts = _.map(items, function (item, i) {\n          var base;\n\n          if (item.base !== void 0) {\n            base = item.base;\n          } else if (records[i] && records[i].doc && records[i].state === \"cached\") {\n            base = records[i].doc;\n          } else if (records[i] && records[i].doc && records[i].state === \"upserted\") {\n            base = records[i].base;\n          } else {\n            base = null;\n          }\n\n          return {\n            col: _this.name,\n            state: \"upserted\",\n            doc: item.doc,\n            base: base\n          };\n        });\n        return _this.store.putBatch(puts, function () {\n          if (success) {\n            return success(docs);\n          }\n        }, error);\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.remove = function (id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch(function (_this) {\n        return function (rows) {\n          return async.each(rows, function (row, cb) {\n            return _this.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        };\n      }(this), error);\n      return;\n    }\n\n    return this.store.get([this.name, id], function (_this) {\n      return function (record) {\n        if (record == null) {\n          record = {\n            col: _this.name,\n            doc: {\n              _id: id\n            }\n          };\n        }\n\n        record.state = \"removed\";\n        return _this.store.put(record, function () {\n          if (success) {\n            return success(id);\n          }\n        }, error);\n      };\n    }(this));\n  };\n\n  Collection.prototype.cache = function (docs, selector, options, success, error) {\n    var keys, puts, step2;\n\n    step2 = function (_this) {\n      return function () {\n        var docsMap, sort;\n        docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n\n        if (options.sort) {\n          sort = compileSort(options.sort);\n        }\n\n        return _this.find(selector, options).fetch(function (results) {\n          var keys, removes;\n          removes = [];\n          keys = _.map(results, function (result) {\n            return [_this.name, result._id];\n          });\n\n          if (keys.length === 0) {\n            if (success != null) {\n              success();\n            }\n\n            return;\n          }\n\n          return _this.store.getBatch(keys, function (records) {\n            var i, record, result, _i, _ref, _ref1;\n\n            for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n              record = records[i];\n              result = results[i];\n\n              if (!docsMap[result._id] && record && record.state === \"cached\") {\n                if (options.limit && docs.length === options.limit) {\n                  if (options.sort && sort(result, _.last(docs)) >= 0) {\n                    continue;\n                  }\n\n                  if (!options.sort) {\n                    continue;\n                  }\n                }\n\n                if (options && options.exclude && (_ref1 = result._id, __indexOf.call(options.exclude, _ref1) >= 0)) {\n                  continue;\n                }\n\n                removes.push([_this.name, result._id]);\n              }\n            }\n\n            if (removes.length > 0) {\n              return _this.store.removeBatch(removes, function () {\n                if (success != null) {\n                  return success();\n                }\n              }, error);\n            } else {\n              if (success != null) {\n                return success();\n              }\n            }\n          }, error);\n        }, error);\n      };\n    }(this);\n\n    if (docs.length === 0) {\n      return step2();\n    }\n\n    keys = _.map(docs, function (_this) {\n      return function (doc) {\n        return [_this.name, doc._id];\n      };\n    }(this));\n    puts = [];\n    return this.store.getBatch(keys, function (_this) {\n      return function (records) {\n        var doc, i, record, _i, _ref, _ref1;\n\n        for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n          doc = docs[i];\n\n          if (record == null || record.state === \"cached\") {\n            if (options && options.exclude && (_ref1 = doc._id, __indexOf.call(options.exclude, _ref1) >= 0)) {\n              continue;\n            }\n\n            if (!record || !doc._rev || !record.doc._rev || doc._rev > record.doc._rev) {\n              puts.push({\n                col: _this.name,\n                state: \"cached\",\n                doc: doc\n              });\n            }\n          }\n        }\n\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, step2, error);\n        } else {\n          return step2();\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function (success, error) {\n    return this.store.query(function (matches) {\n      var upserts;\n      upserts = _.map(matches, function (m) {\n        return {\n          doc: m.doc,\n          base: m.base || null\n        };\n      });\n\n      if (success != null) {\n        return success(upserts);\n      }\n    }, {\n      index: \"col-state\",\n      keyRange: this.store.makeKeyRange({\n        only: [this.name, \"upserted\"]\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.pendingRemoves = function (success, error) {\n    return this.store.query(function (matches) {\n      if (success != null) {\n        return success(_.pluck(_.pluck(matches, \"doc\"), \"_id\"));\n      }\n    }, {\n      index: \"col-state\",\n      keyRange: this.store.makeKeyRange({\n        only: [this.name, \"removed\"]\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.resolveUpserts = function (upserts, success, error) {\n    var keys;\n    keys = _.map(upserts, function (_this) {\n      return function (upsert) {\n        return [_this.name, upsert.doc._id];\n      };\n    }(this));\n    return this.store.getBatch(keys, function (_this) {\n      return function (records) {\n        var i, puts, record, _i, _ref;\n\n        puts = [];\n\n        for (i = _i = 0, _ref = upserts.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n\n          if (record && record.state === \"upserted\") {\n            if (_.isEqual(record.doc, upserts[i].doc)) {\n              record.state = \"cached\";\n              puts.push(record);\n            } else {\n              record.base = upserts[i].doc;\n              puts.push(record);\n            }\n          }\n        }\n\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, function () {\n            if (success) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success) {\n            return success();\n          }\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.resolveRemove = function (id, success, error) {\n    return this.store.get([this.name, id], function (_this) {\n      return function (record) {\n        if (!record) {\n          if (success != null) {\n            success();\n          }\n\n          return;\n        }\n\n        if (record.state === \"removed\") {\n          return _this.store.remove([_this.name, id], function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        }\n      };\n    }(this));\n  };\n\n  Collection.prototype.seed = function (docs, success, error) {\n    var keys, puts;\n\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n\n    keys = _.map(docs, function (_this) {\n      return function (doc) {\n        return [_this.name, doc._id];\n      };\n    }(this));\n    puts = [];\n    return this.store.getBatch(keys, function (_this) {\n      return function (records) {\n        var doc, i, record, _i, _ref;\n\n        for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n          doc = docs[i];\n\n          if (record == null) {\n            puts.push({\n              col: _this.name,\n              state: \"cached\",\n              doc: doc\n            });\n          }\n        }\n\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.cacheOne = function (doc, success, error) {\n    return this.cacheList([doc], success, error);\n  };\n\n  Collection.prototype.cacheList = function (docs, success, error) {\n    var keys, puts;\n    keys = _.map(docs, function (_this) {\n      return function (doc) {\n        return [_this.name, doc._id];\n      };\n    }(this));\n    puts = [];\n    return this.store.getBatch(keys, function (_this) {\n      return function (records) {\n        var doc, i, record, _i, _ref;\n\n        for (i = _i = 0, _ref = records.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n          record = records[i];\n          doc = docs[i];\n\n          if (record && doc._rev && record.doc._rev && doc._rev <= record.doc._rev) {\n            continue;\n          }\n\n          if (record == null) {\n            record = {\n              col: _this.name,\n              state: \"cached\",\n              doc: doc\n            };\n          }\n\n          if (record.state === \"cached\") {\n            record.doc = doc;\n            puts.push(record);\n          }\n        }\n\n        if (puts.length > 0) {\n          return _this.store.putBatch(puts, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.uncache = function (selector, success, error) {\n    var compiledSelector;\n    compiledSelector = utils.compileDocumentSelector(selector);\n    return this.store.query(function (_this) {\n      return function (matches) {\n        var keys;\n        matches = _.filter(matches, function (m) {\n          return m.state === \"cached\" && compiledSelector(m.doc);\n        });\n        keys = _.map(matches, function (m) {\n          return [_this.name, m.doc._id];\n        });\n\n        if (keys.length > 0) {\n          return _this.store.removeBatch(keys, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    }(this), {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  };\n\n  Collection.prototype.uncacheList = function (ids, success, error) {\n    var idIndex;\n    idIndex = _.indexBy(ids);\n\n    error = error || function () {};\n\n    return this.store.query(function (_this) {\n      return function (matches) {\n        var keys;\n        matches = _.filter(matches, function (m) {\n          return m.state === \"cached\" && idIndex[m.doc._id];\n        });\n        keys = _.map(matches, function (m) {\n          return [_this.name, m.doc._id];\n        });\n\n        if (keys.length > 0) {\n          return _this.store.removeBatch(keys, function () {\n            if (success != null) {\n              return success();\n            }\n          }, error);\n        } else {\n          if (success != null) {\n            return success();\n          }\n        }\n      };\n    }(this), {\n      index: \"col\",\n      keyRange: this.store.makeKeyRange({\n        only: this.name\n      }),\n      onError: error\n    });\n  };\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}