{"ast":null,"code":"import FakeXMLHttpRequest from 'fake-xml-http-request';\nimport RouteRecognizer from 'route-recognizer';\nvar support = {\n  searchParams: 'URLSearchParams' in self,\n  iterable: 'Symbol' in self && 'iterator' in Symbol,\n  blob: 'FileReader' in self && 'Blob' in self && function () {\n    try {\n      new Blob();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }(),\n  formData: 'FormData' in self,\n  arrayBuffer: 'ArrayBuffer' in self\n};\n\nfunction isDataView(obj) {\n  return obj && DataView.prototype.isPrototypeOf(obj);\n}\n\nif (support.arrayBuffer) {\n  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];\n\n  var isArrayBufferView = ArrayBuffer.isView || function (obj) {\n    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;\n  };\n}\n\nfunction normalizeName(name) {\n  if (typeof name !== 'string') {\n    name = String(name);\n  }\n\n  if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n    throw new TypeError('Invalid character in header field name');\n  }\n\n  return name.toLowerCase();\n}\n\nfunction normalizeValue(value) {\n  if (typeof value !== 'string') {\n    value = String(value);\n  }\n\n  return value;\n} // Build a destructive iterator for the value list\n\n\nfunction iteratorFor(items) {\n  var iterator = {\n    next: function () {\n      var value = items.shift();\n      return {\n        done: value === undefined,\n        value: value\n      };\n    }\n  };\n\n  if (support.iterable) {\n    iterator[Symbol.iterator] = function () {\n      return iterator;\n    };\n  }\n\n  return iterator;\n}\n\nfunction Headers(headers) {\n  this.map = {};\n\n  if (headers instanceof Headers) {\n    headers.forEach(function (value, name) {\n      this.append(name, value);\n    }, this);\n  } else if (Array.isArray(headers)) {\n    headers.forEach(function (header) {\n      this.append(header[0], header[1]);\n    }, this);\n  } else if (headers) {\n    Object.getOwnPropertyNames(headers).forEach(function (name) {\n      this.append(name, headers[name]);\n    }, this);\n  }\n}\n\nHeaders.prototype.append = function (name, value) {\n  name = normalizeName(name);\n  value = normalizeValue(value);\n  var oldValue = this.map[name];\n  this.map[name] = oldValue ? oldValue + ', ' + value : value;\n};\n\nHeaders.prototype['delete'] = function (name) {\n  delete this.map[normalizeName(name)];\n};\n\nHeaders.prototype.get = function (name) {\n  name = normalizeName(name);\n  return this.has(name) ? this.map[name] : null;\n};\n\nHeaders.prototype.has = function (name) {\n  return this.map.hasOwnProperty(normalizeName(name));\n};\n\nHeaders.prototype.set = function (name, value) {\n  this.map[normalizeName(name)] = normalizeValue(value);\n};\n\nHeaders.prototype.forEach = function (callback, thisArg) {\n  for (var name in this.map) {\n    if (this.map.hasOwnProperty(name)) {\n      callback.call(thisArg, this.map[name], name, this);\n    }\n  }\n};\n\nHeaders.prototype.keys = function () {\n  var items = [];\n  this.forEach(function (value, name) {\n    items.push(name);\n  });\n  return iteratorFor(items);\n};\n\nHeaders.prototype.values = function () {\n  var items = [];\n  this.forEach(function (value) {\n    items.push(value);\n  });\n  return iteratorFor(items);\n};\n\nHeaders.prototype.entries = function () {\n  var items = [];\n  this.forEach(function (value, name) {\n    items.push([name, value]);\n  });\n  return iteratorFor(items);\n};\n\nif (support.iterable) {\n  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n}\n\nfunction consumed(body) {\n  if (body.bodyUsed) {\n    return Promise.reject(new TypeError('Already read'));\n  }\n\n  body.bodyUsed = true;\n}\n\nfunction fileReaderReady(reader) {\n  return new Promise(function (resolve, reject) {\n    reader.onload = function () {\n      resolve(reader.result);\n    };\n\n    reader.onerror = function () {\n      reject(reader.error);\n    };\n  });\n}\n\nfunction readBlobAsArrayBuffer(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  reader.readAsArrayBuffer(blob);\n  return promise;\n}\n\nfunction readBlobAsText(blob) {\n  var reader = new FileReader();\n  var promise = fileReaderReady(reader);\n  reader.readAsText(blob);\n  return promise;\n}\n\nfunction readArrayBufferAsText(buf) {\n  var view = new Uint8Array(buf);\n  var chars = new Array(view.length);\n\n  for (var i = 0; i < view.length; i++) {\n    chars[i] = String.fromCharCode(view[i]);\n  }\n\n  return chars.join('');\n}\n\nfunction bufferClone(buf) {\n  if (buf.slice) {\n    return buf.slice(0);\n  } else {\n    var view = new Uint8Array(buf.byteLength);\n    view.set(new Uint8Array(buf));\n    return view.buffer;\n  }\n}\n\nfunction Body() {\n  this.bodyUsed = false;\n\n  this._initBody = function (body) {\n    this._bodyInit = body;\n\n    if (!body) {\n      this._bodyText = '';\n    } else if (typeof body === 'string') {\n      this._bodyText = body;\n    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n      this._bodyBlob = body;\n    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n      this._bodyFormData = body;\n    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n      this._bodyText = body.toString();\n    } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n      this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.\n\n      this._bodyInit = new Blob([this._bodyArrayBuffer]);\n    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n      this._bodyArrayBuffer = bufferClone(body);\n    } else {\n      this._bodyText = body = Object.prototype.toString.call(body);\n    }\n\n    if (!this.headers.get('content-type')) {\n      if (typeof body === 'string') {\n        this.headers.set('content-type', 'text/plain;charset=UTF-8');\n      } else if (this._bodyBlob && this._bodyBlob.type) {\n        this.headers.set('content-type', this._bodyBlob.type);\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n      }\n    }\n  };\n\n  if (support.blob) {\n    this.blob = function () {\n      var rejected = consumed(this);\n\n      if (rejected) {\n        return rejected;\n      }\n\n      if (this._bodyBlob) {\n        return Promise.resolve(this._bodyBlob);\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(new Blob([this._bodyArrayBuffer]));\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as blob');\n      } else {\n        return Promise.resolve(new Blob([this._bodyText]));\n      }\n    };\n\n    this.arrayBuffer = function () {\n      if (this._bodyArrayBuffer) {\n        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);\n      } else {\n        return this.blob().then(readBlobAsArrayBuffer);\n      }\n    };\n  }\n\n  this.text = function () {\n    var rejected = consumed(this);\n\n    if (rejected) {\n      return rejected;\n    }\n\n    if (this._bodyBlob) {\n      return readBlobAsText(this._bodyBlob);\n    } else if (this._bodyArrayBuffer) {\n      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));\n    } else if (this._bodyFormData) {\n      throw new Error('could not read FormData body as text');\n    } else {\n      return Promise.resolve(this._bodyText);\n    }\n  };\n\n  if (support.formData) {\n    this.formData = function () {\n      return this.text().then(decode);\n    };\n  }\n\n  this.json = function () {\n    return this.text().then(JSON.parse);\n  };\n\n  return this;\n} // HTTP methods whose capitalization should be normalized\n\n\nvar methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\nfunction normalizeMethod(method) {\n  var upcased = method.toUpperCase();\n  return methods.indexOf(upcased) > -1 ? upcased : method;\n}\n\nfunction Request(input, options) {\n  options = options || {};\n  var body = options.body;\n\n  if (input instanceof Request) {\n    if (input.bodyUsed) {\n      throw new TypeError('Already read');\n    }\n\n    this.url = input.url;\n    this.credentials = input.credentials;\n\n    if (!options.headers) {\n      this.headers = new Headers(input.headers);\n    }\n\n    this.method = input.method;\n    this.mode = input.mode;\n    this.signal = input.signal;\n\n    if (!body && input._bodyInit != null) {\n      body = input._bodyInit;\n      input.bodyUsed = true;\n    }\n  } else {\n    this.url = String(input);\n  }\n\n  this.credentials = options.credentials || this.credentials || 'same-origin';\n\n  if (options.headers || !this.headers) {\n    this.headers = new Headers(options.headers);\n  }\n\n  this.method = normalizeMethod(options.method || this.method || 'GET');\n  this.mode = options.mode || this.mode || null;\n  this.signal = options.signal || this.signal;\n  this.referrer = null;\n\n  if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n    throw new TypeError('Body not allowed for GET or HEAD requests');\n  }\n\n  this._initBody(body);\n}\n\nRequest.prototype.clone = function () {\n  return new Request(this, {\n    body: this._bodyInit\n  });\n};\n\nfunction decode(body) {\n  var form = new FormData();\n  body.trim().split('&').forEach(function (bytes) {\n    if (bytes) {\n      var split = bytes.split('=');\n      var name = split.shift().replace(/\\+/g, ' ');\n      var value = split.join('=').replace(/\\+/g, ' ');\n      form.append(decodeURIComponent(name), decodeURIComponent(value));\n    }\n  });\n  return form;\n}\n\nfunction parseHeaders(rawHeaders) {\n  var headers = new Headers(); // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n  // https://tools.ietf.org/html/rfc7230#section-3.2\n\n  var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n  preProcessedHeaders.split(/\\r?\\n/).forEach(function (line) {\n    var parts = line.split(':');\n    var key = parts.shift().trim();\n\n    if (key) {\n      var value = parts.join(':').trim();\n      headers.append(key, value);\n    }\n  });\n  return headers;\n}\n\nBody.call(Request.prototype);\n\nfunction Response(bodyInit, options) {\n  if (!options) {\n    options = {};\n  }\n\n  this.type = 'default';\n  this.status = options.status === undefined ? 200 : options.status;\n  this.ok = this.status >= 200 && this.status < 300;\n  this.statusText = 'statusText' in options ? options.statusText : 'OK';\n  this.headers = new Headers(options.headers);\n  this.url = options.url || '';\n\n  this._initBody(bodyInit);\n}\n\nBody.call(Response.prototype);\n\nResponse.prototype.clone = function () {\n  return new Response(this._bodyInit, {\n    status: this.status,\n    statusText: this.statusText,\n    headers: new Headers(this.headers),\n    url: this.url\n  });\n};\n\nResponse.error = function () {\n  var response = new Response(null, {\n    status: 0,\n    statusText: ''\n  });\n  response.type = 'error';\n  return response;\n};\n\nvar redirectStatuses = [301, 302, 303, 307, 308];\n\nResponse.redirect = function (url, status) {\n  if (redirectStatuses.indexOf(status) === -1) {\n    throw new RangeError('Invalid status code');\n  }\n\n  return new Response(null, {\n    status: status,\n    headers: {\n      location: url\n    }\n  });\n};\n\nvar DOMException = self.DOMException;\n\ntry {\n  new DOMException();\n} catch (err) {\n  DOMException = function (message, name) {\n    this.message = message;\n    this.name = name;\n    var error = Error(message);\n    this.stack = error.stack;\n  };\n\n  DOMException.prototype = Object.create(Error.prototype);\n  DOMException.prototype.constructor = DOMException;\n}\n\nfunction fetch(input, init) {\n  return new Promise(function (resolve, reject) {\n    var request = new Request(input, init);\n\n    if (request.signal && request.signal.aborted) {\n      return reject(new DOMException('Aborted', 'AbortError'));\n    }\n\n    var xhr = new XMLHttpRequest();\n\n    function abortXhr() {\n      xhr.abort();\n    }\n\n    xhr.onload = function () {\n      var options = {\n        status: xhr.status,\n        statusText: xhr.statusText,\n        headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n      };\n      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n      var body = 'response' in xhr ? xhr.response : xhr.responseText;\n      resolve(new Response(body, options));\n    };\n\n    xhr.onerror = function () {\n      reject(new TypeError('Network request failed'));\n    };\n\n    xhr.ontimeout = function () {\n      reject(new TypeError('Network request failed'));\n    };\n\n    xhr.onabort = function () {\n      reject(new DOMException('Aborted', 'AbortError'));\n    };\n\n    xhr.open(request.method, request.url, true);\n\n    if (request.credentials === 'include') {\n      xhr.withCredentials = true;\n    } else if (request.credentials === 'omit') {\n      xhr.withCredentials = false;\n    }\n\n    if ('responseType' in xhr && support.blob) {\n      xhr.responseType = 'blob';\n    }\n\n    request.headers.forEach(function (value, name) {\n      xhr.setRequestHeader(name, value);\n    });\n\n    if (request.signal) {\n      request.signal.addEventListener('abort', abortXhr);\n\n      xhr.onreadystatechange = function () {\n        // DONE (success or failure)\n        if (xhr.readyState === 4) {\n          request.signal.removeEventListener('abort', abortXhr);\n        }\n      };\n    }\n\n    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n  });\n}\n\nfetch.polyfill = true;\n\nif (!self.fetch) {\n  self.fetch = fetch;\n  self.Headers = Headers;\n  self.Request = Request;\n  self.Response = Response;\n}\n\nvar FakeFetch =\n/*#__PURE__*/\nObject.freeze({\n  __proto__: null,\n  Headers: Headers,\n  Request: Request,\n  Response: Response,\n\n  get DOMException() {\n    return DOMException;\n  },\n\n  fetch: fetch\n});\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n/**\n * Check if we're required to add a port number.\n *\n * @see https://url.spec.whatwg.org/#default-port\n * @param {Number|String} port Port number we need to check\n * @param {String} protocol Protocol we need to check against.\n * @returns {Boolean} Is it a default port for the given protocol\n * @api private\n */\n\nvar requiresPort = function required(port, protocol) {\n  protocol = protocol.split(':')[0];\n  port = +port;\n  if (!port) return false;\n\n  switch (protocol) {\n    case 'http':\n    case 'ws':\n      return port !== 80;\n\n    case 'https':\n    case 'wss':\n      return port !== 443;\n\n    case 'ftp':\n      return port !== 21;\n\n    case 'gopher':\n      return port !== 70;\n\n    case 'file':\n      return false;\n  }\n\n  return port !== 0;\n};\n\nvar has = Object.prototype.hasOwnProperty,\n    undef;\n/**\n * Decode a URI encoded string.\n *\n * @param {String} input The URI encoded string.\n * @returns {String|Null} The decoded string.\n * @api private\n */\n\nfunction decode$1(input) {\n  try {\n    return decodeURIComponent(input.replace(/\\+/g, ' '));\n  } catch (e) {\n    return null;\n  }\n}\n/**\n * Simple query string parser.\n *\n * @param {String} query The query string that needs to be parsed.\n * @returns {Object}\n * @api public\n */\n\n\nfunction querystring(query) {\n  var parser = /([^=?&]+)=?([^&]*)/g,\n      result = {},\n      part;\n\n  while (part = parser.exec(query)) {\n    var key = decode$1(part[1]),\n        value = decode$1(part[2]); //\n    // Prevent overriding of existing properties. This ensures that build-in\n    // methods like `toString` or __proto__ are not overriden by malicious\n    // querystrings.\n    //\n    // In the case if failed decoding, we want to omit the key/value pairs\n    // from the result.\n    //\n\n    if (key === null || value === null || key in result) continue;\n    result[key] = value;\n  }\n\n  return result;\n}\n/**\n * Transform a query string to an object.\n *\n * @param {Object} obj Object that should be transformed.\n * @param {String} prefix Optional prefix.\n * @returns {String}\n * @api public\n */\n\n\nfunction querystringify(obj, prefix) {\n  prefix = prefix || '';\n  var pairs = [],\n      value,\n      key; //\n  // Optionally prefix with a '?' if needed\n  //\n\n  if ('string' !== typeof prefix) prefix = '?';\n\n  for (key in obj) {\n    if (has.call(obj, key)) {\n      value = obj[key]; //\n      // Edge cases where we actually want to encode the value to an empty\n      // string instead of the stringified value.\n      //\n\n      if (!value && (value === null || value === undef || isNaN(value))) {\n        value = '';\n      }\n\n      key = encodeURIComponent(key);\n      value = encodeURIComponent(value); //\n      // If we failed to encode the strings, we should bail out as we don't\n      // want to add invalid strings to the query.\n      //\n\n      if (key === null || value === null) continue;\n      pairs.push(key + '=' + value);\n    }\n  }\n\n  return pairs.length ? prefix + pairs.join('&') : '';\n} //\n// Expose the module.\n//\n\n\nvar stringify = querystringify;\nvar parse = querystring;\nvar querystringify_1 = {\n  stringify: stringify,\n  parse: parse\n};\nvar slashes = /^[A-Za-z][A-Za-z0-9+-.]*:\\/\\//,\n    protocolre = /^([a-z][a-z0-9.+-]*:)?(\\/\\/)?([\\S\\s]*)/i,\n    whitespace = '[\\\\x09\\\\x0A\\\\x0B\\\\x0C\\\\x0D\\\\x20\\\\xA0\\\\u1680\\\\u180E\\\\u2000\\\\u2001\\\\u2002\\\\u2003\\\\u2004\\\\u2005\\\\u2006\\\\u2007\\\\u2008\\\\u2009\\\\u200A\\\\u202F\\\\u205F\\\\u3000\\\\u2028\\\\u2029\\\\uFEFF]',\n    left = new RegExp('^' + whitespace + '+');\n/**\n * Trim a given string.\n *\n * @param {String} str String to trim.\n * @public\n */\n\nfunction trimLeft(str) {\n  return (str ? str : '').toString().replace(left, '');\n}\n/**\n * These are the parse rules for the URL parser, it informs the parser\n * about:\n *\n * 0. The char it Needs to parse, if it's a string it should be done using\n *    indexOf, RegExp using exec and NaN means set as current value.\n * 1. The property we should set when parsing this value.\n * 2. Indication if it's backwards or forward parsing, when set as number it's\n *    the value of extra chars that should be split off.\n * 3. Inherit from location if non existing in the parser.\n * 4. `toLowerCase` the resulting value.\n */\n\n\nvar rules = [['#', 'hash'], // Extract from the back.\n['?', 'query'], // Extract from the back.\nfunction sanitize(address) {\n  // Sanitize what is left of the address\n  return address.replace('\\\\', '/');\n}, ['/', 'pathname'], // Extract from the back.\n['@', 'auth', 1], // Extract from the front.\n[NaN, 'host', undefined, 1, 1], // Set left over value.\n[/:(\\d+)$/, 'port', undefined, 1], // RegExp the back.\n[NaN, 'hostname', undefined, 1, 1] // Set left over.\n];\n/**\n * These properties should not be copied or inherited from. This is only needed\n * for all non blob URL's as a blob URL does not include a hash, only the\n * origin.\n *\n * @type {Object}\n * @private\n */\n\nvar ignore = {\n  hash: 1,\n  query: 1\n};\n/**\n * The location object differs when your code is loaded through a normal page,\n * Worker or through a worker using a blob. And with the blobble begins the\n * trouble as the location object will contain the URL of the blob, not the\n * location of the page where our code is loaded in. The actual origin is\n * encoded in the `pathname` so we can thankfully generate a good \"default\"\n * location from it so we can generate proper relative URL's again.\n *\n * @param {Object|String} loc Optional default location object.\n * @returns {Object} lolcation object.\n * @public\n */\n\nfunction lolcation(loc) {\n  var globalVar;\n  if (typeof window !== 'undefined') globalVar = window;else if (typeof commonjsGlobal !== 'undefined') globalVar = commonjsGlobal;else if (typeof self !== 'undefined') globalVar = self;else globalVar = {};\n  var location = globalVar.location || {};\n  loc = loc || location;\n  var finaldestination = {},\n      type = typeof loc,\n      key;\n\n  if ('blob:' === loc.protocol) {\n    finaldestination = new Url(unescape(loc.pathname), {});\n  } else if ('string' === type) {\n    finaldestination = new Url(loc, {});\n\n    for (key in ignore) delete finaldestination[key];\n  } else if ('object' === type) {\n    for (key in loc) {\n      if (key in ignore) continue;\n      finaldestination[key] = loc[key];\n    }\n\n    if (finaldestination.slashes === undefined) {\n      finaldestination.slashes = slashes.test(loc.href);\n    }\n  }\n\n  return finaldestination;\n}\n/**\n * @typedef ProtocolExtract\n * @type Object\n * @property {String} protocol Protocol matched in the URL, in lowercase.\n * @property {Boolean} slashes `true` if protocol is followed by \"//\", else `false`.\n * @property {String} rest Rest of the URL that is not part of the protocol.\n */\n\n/**\n * Extract protocol information from a URL with/without double slash (\"//\").\n *\n * @param {String} address URL we want to extract from.\n * @return {ProtocolExtract} Extracted information.\n * @private\n */\n\n\nfunction extractProtocol(address) {\n  address = trimLeft(address);\n  var match = protocolre.exec(address);\n  return {\n    protocol: match[1] ? match[1].toLowerCase() : '',\n    slashes: !!match[2],\n    rest: match[3]\n  };\n}\n/**\n * Resolve a relative URL pathname against a base URL pathname.\n *\n * @param {String} relative Pathname of the relative URL.\n * @param {String} base Pathname of the base URL.\n * @return {String} Resolved pathname.\n * @private\n */\n\n\nfunction resolve(relative, base) {\n  if (relative === '') return base;\n  var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/')),\n      i = path.length,\n      last = path[i - 1],\n      unshift = false,\n      up = 0;\n\n  while (i--) {\n    if (path[i] === '.') {\n      path.splice(i, 1);\n    } else if (path[i] === '..') {\n      path.splice(i, 1);\n      up++;\n    } else if (up) {\n      if (i === 0) unshift = true;\n      path.splice(i, 1);\n      up--;\n    }\n  }\n\n  if (unshift) path.unshift('');\n  if (last === '.' || last === '..') path.push('');\n  return path.join('/');\n}\n/**\n * The actual URL instance. Instead of returning an object we've opted-in to\n * create an actual constructor as it's much more memory efficient and\n * faster and it pleases my OCD.\n *\n * It is worth noting that we should not use `URL` as class name to prevent\n * clashes with the global URL instance that got introduced in browsers.\n *\n * @constructor\n * @param {String} address URL we want to parse.\n * @param {Object|String} [location] Location defaults for relative paths.\n * @param {Boolean|Function} [parser] Parser for the query string.\n * @private\n */\n\n\nfunction Url(address, location, parser) {\n  address = trimLeft(address);\n\n  if (!(this instanceof Url)) {\n    return new Url(address, location, parser);\n  }\n\n  var relative,\n      extracted,\n      parse,\n      instruction,\n      index,\n      key,\n      instructions = rules.slice(),\n      type = typeof location,\n      url = this,\n      i = 0; //\n  // The following if statements allows this module two have compatibility with\n  // 2 different API:\n  //\n  // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments\n  //    where the boolean indicates that the query string should also be parsed.\n  //\n  // 2. The `URL` interface of the browser which accepts a URL, object as\n  //    arguments. The supplied object will be used as default values / fall-back\n  //    for relative paths.\n  //\n\n  if ('object' !== type && 'string' !== type) {\n    parser = location;\n    location = null;\n  }\n\n  if (parser && 'function' !== typeof parser) parser = querystringify_1.parse;\n  location = lolcation(location); //\n  // Extract protocol information before running the instructions.\n  //\n\n  extracted = extractProtocol(address || '');\n  relative = !extracted.protocol && !extracted.slashes;\n  url.slashes = extracted.slashes || relative && location.slashes;\n  url.protocol = extracted.protocol || location.protocol || '';\n  address = extracted.rest; //\n  // When the authority component is absent the URL starts with a path\n  // component.\n  //\n\n  if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];\n\n  for (; i < instructions.length; i++) {\n    instruction = instructions[i];\n\n    if (typeof instruction === 'function') {\n      address = instruction(address);\n      continue;\n    }\n\n    parse = instruction[0];\n    key = instruction[1];\n\n    if (parse !== parse) {\n      url[key] = address;\n    } else if ('string' === typeof parse) {\n      if (~(index = address.indexOf(parse))) {\n        if ('number' === typeof instruction[2]) {\n          url[key] = address.slice(0, index);\n          address = address.slice(index + instruction[2]);\n        } else {\n          url[key] = address.slice(index);\n          address = address.slice(0, index);\n        }\n      }\n    } else if (index = parse.exec(address)) {\n      url[key] = index[1];\n      address = address.slice(0, index.index);\n    }\n\n    url[key] = url[key] || (relative && instruction[3] ? location[key] || '' : ''); //\n    // Hostname, host and protocol should be lowercased so they can be used to\n    // create a proper `origin`.\n    //\n\n    if (instruction[4]) url[key] = url[key].toLowerCase();\n  } //\n  // Also parse the supplied query string in to an object. If we're supplied\n  // with a custom parser as function use that instead of the default build-in\n  // parser.\n  //\n\n\n  if (parser) url.query = parser(url.query); //\n  // If the URL is relative, resolve the pathname against the base URL.\n  //\n\n  if (relative && location.slashes && url.pathname.charAt(0) !== '/' && (url.pathname !== '' || location.pathname !== '')) {\n    url.pathname = resolve(url.pathname, location.pathname);\n  } //\n  // We should not add port numbers if they are already the default port number\n  // for a given protocol. As the host also contains the port number we're going\n  // override it with the hostname which contains no port number.\n  //\n\n\n  if (!requiresPort(url.port, url.protocol)) {\n    url.host = url.hostname;\n    url.port = '';\n  } //\n  // Parse down the `auth` for the username and password.\n  //\n\n\n  url.username = url.password = '';\n\n  if (url.auth) {\n    instruction = url.auth.split(':');\n    url.username = instruction[0] || '';\n    url.password = instruction[1] || '';\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null'; //\n  // The href is just the compiled result.\n  //\n\n  url.href = url.toString();\n}\n/**\n * This is convenience method for changing properties in the URL instance to\n * insure that they all propagate correctly.\n *\n * @param {String} part          Property we need to adjust.\n * @param {Mixed} value          The newly assigned value.\n * @param {Boolean|Function} fn  When setting the query, it will be the function\n *                               used to parse the query.\n *                               When setting the protocol, double slash will be\n *                               removed from the final url if it is true.\n * @returns {URL} URL instance for chaining.\n * @public\n */\n\n\nfunction set(part, value, fn) {\n  var url = this;\n\n  switch (part) {\n    case 'query':\n      if ('string' === typeof value && value.length) {\n        value = (fn || querystringify_1.parse)(value);\n      }\n\n      url[part] = value;\n      break;\n\n    case 'port':\n      url[part] = value;\n\n      if (!requiresPort(value, url.protocol)) {\n        url.host = url.hostname;\n        url[part] = '';\n      } else if (value) {\n        url.host = url.hostname + ':' + value;\n      }\n\n      break;\n\n    case 'hostname':\n      url[part] = value;\n      if (url.port) value += ':' + url.port;\n      url.host = value;\n      break;\n\n    case 'host':\n      url[part] = value;\n\n      if (/:\\d+$/.test(value)) {\n        value = value.split(':');\n        url.port = value.pop();\n        url.hostname = value.join(':');\n      } else {\n        url.hostname = value;\n        url.port = '';\n      }\n\n      break;\n\n    case 'protocol':\n      url.protocol = value.toLowerCase();\n      url.slashes = !fn;\n      break;\n\n    case 'pathname':\n    case 'hash':\n      if (value) {\n        var char = part === 'pathname' ? '/' : '#';\n        url[part] = value.charAt(0) !== char ? char + value : value;\n      } else {\n        url[part] = value;\n      }\n\n      break;\n\n    default:\n      url[part] = value;\n  }\n\n  for (var i = 0; i < rules.length; i++) {\n    var ins = rules[i];\n    if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();\n  }\n\n  url.origin = url.protocol && url.host && url.protocol !== 'file:' ? url.protocol + '//' + url.host : 'null';\n  url.href = url.toString();\n  return url;\n}\n/**\n * Transform the properties back in to a valid and full URL string.\n *\n * @param {Function} stringify Optional query stringify function.\n * @returns {String} Compiled version of the URL.\n * @public\n */\n\n\nfunction toString(stringify) {\n  if (!stringify || 'function' !== typeof stringify) stringify = querystringify_1.stringify;\n  var query,\n      url = this,\n      protocol = url.protocol;\n  if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';\n  var result = protocol + (url.slashes ? '//' : '');\n\n  if (url.username) {\n    result += url.username;\n    if (url.password) result += ':' + url.password;\n    result += '@';\n  }\n\n  result += url.host + url.pathname;\n  query = 'object' === typeof url.query ? stringify(url.query) : url.query;\n  if (query) result += '?' !== query.charAt(0) ? '?' + query : query;\n  if (url.hash) result += url.hash;\n  return result;\n}\n\nUrl.prototype = {\n  set: set,\n  toString: toString\n}; //\n// Expose the URL parser and some additional properties that might be useful for\n// others or testing.\n//\n\nUrl.extractProtocol = extractProtocol;\nUrl.location = lolcation;\nUrl.trimLeft = trimLeft;\nUrl.qs = querystringify_1;\nvar urlParse = Url;\n/**\n * parseURL - decompose a URL into its parts\n * @param  {String} url a URL\n * @return {Object} parts of the URL, including the following\n *\n * 'https://www.yahoo.com:1234/mypage?test=yes#abc'\n *\n * {\n *   host: 'www.yahoo.com:1234',\n *   protocol: 'https:',\n *   search: '?test=yes',\n *   hash: '#abc',\n *   href: 'https://www.yahoo.com:1234/mypage?test=yes#abc',\n *   pathname: '/mypage',\n *   fullpath: '/mypage?test=yes'\n * }\n */\n\nfunction parseURL(url) {\n  var parsedUrl = new urlParse(url);\n\n  if (!parsedUrl.host) {\n    // eslint-disable-next-line no-self-assign\n    parsedUrl.href = parsedUrl.href; // IE: load the host and protocol\n  }\n\n  var pathname = parsedUrl.pathname;\n\n  if (pathname.charAt(0) !== '/') {\n    pathname = '/' + pathname; // IE: prepend leading slash\n  }\n\n  var host = parsedUrl.host;\n\n  if (parsedUrl.port === '80' || parsedUrl.port === '443') {\n    host = parsedUrl.hostname; // IE: remove default port\n  }\n\n  return {\n    host: host,\n    protocol: parsedUrl.protocol,\n    search: parsedUrl.query,\n    hash: parsedUrl.hash,\n    href: parsedUrl.href,\n    pathname: pathname,\n    fullpath: pathname + (parsedUrl.query || '') + (parsedUrl.hash || '')\n  };\n}\n/**\n * Registry\n *\n * A registry is a map of HTTP verbs to route recognizers.\n */\n\n\nvar Registry =\n/** @class */\nfunction () {\n  function Registry()\n  /* host */\n  {\n    // Herein we keep track of RouteRecognizer instances\n    // keyed by HTTP method. Feel free to add more as needed.\n    this.verbs = {\n      GET: new RouteRecognizer(),\n      PUT: new RouteRecognizer(),\n      POST: new RouteRecognizer(),\n      DELETE: new RouteRecognizer(),\n      PATCH: new RouteRecognizer(),\n      HEAD: new RouteRecognizer(),\n      OPTIONS: new RouteRecognizer()\n    };\n  }\n\n  return Registry;\n}();\n/**\n * Hosts\n *\n * a map of hosts to Registries, ultimately allowing\n * a per-host-and-port, per HTTP verb lookup of RouteRecognizers\n */\n\n\nfunction Hosts() {\n  this._registries = {};\n}\n/**\n * Hosts#forURL - retrieve a map of HTTP verbs to RouteRecognizers\n *                for a given URL\n *\n * @param  {String} url a URL\n * @return {Registry}   a map of HTTP verbs to RouteRecognizers\n *                      corresponding to the provided URL's\n *                      hostname and port\n */\n\n\nHosts.prototype.forURL = function (url) {\n  var host = parseURL(url).host;\n  var registry = this._registries[host];\n\n  if (registry === undefined) {\n    registry = this._registries[host] = new Registry(host);\n  }\n\n  return registry.verbs;\n};\n\nfunction Pretender()\n/* routeMap1, routeMap2, ..., options*/\n{\n  this.hosts = new Hosts();\n  var lastArg = arguments[arguments.length - 1];\n  var options = typeof lastArg === 'object' ? lastArg : null;\n  var shouldNotTrack = options && options.trackRequests === false;\n  var noopArray = {\n    push: function () {},\n    length: 0\n  };\n  this.handlers = [];\n  this.handledRequests = shouldNotTrack ? noopArray : [];\n  this.passthroughRequests = shouldNotTrack ? noopArray : [];\n  this.unhandledRequests = shouldNotTrack ? noopArray : [];\n  this.requestReferences = [];\n  this.forcePassthrough = options && options.forcePassthrough === true;\n  this.disableUnhandled = options && options.disableUnhandled === true; // reference the native XMLHttpRequest object so\n  // it can be restored later\n\n  this._nativeXMLHttpRequest = self.XMLHttpRequest;\n  this.running = false;\n  var ctx = {\n    pretender: this\n  };\n  this.ctx = ctx; // capture xhr requests, channeling them into\n  // the route map.\n\n  self.XMLHttpRequest = interceptor(ctx); // polyfill fetch when xhr is ready\n\n  this._fetchProps = FakeFetch ? ['fetch', 'Headers', 'Request', 'Response'] : [];\n\n  this._fetchProps.forEach(function (name) {\n    this['_native' + name] = self[name];\n    self[name] = FakeFetch[name];\n  }, this); // 'start' the server\n\n\n  this.running = true; // trigger the route map DSL.\n\n  var argLength = options ? arguments.length - 1 : arguments.length;\n\n  for (var i = 0; i < argLength; i++) {\n    this.map(arguments[i]);\n  }\n}\n\nfunction interceptor(ctx) {\n  function FakeRequest() {\n    // super()\n    FakeXMLHttpRequest.call(this);\n  }\n\n  FakeRequest.prototype = Object.create(FakeXMLHttpRequest.prototype);\n  FakeRequest.prototype.constructor = FakeRequest; // extend\n\n  FakeRequest.prototype.send = function send() {\n    this.sendArguments = arguments;\n\n    if (!ctx.pretender.running) {\n      throw new Error('You shut down a Pretender instance while there was a pending request. ' + 'That request just tried to complete. Check to see if you accidentally shut down ' + 'a pretender earlier than you intended to');\n    }\n\n    FakeXMLHttpRequest.prototype.send.apply(this, arguments);\n\n    if (ctx.pretender.checkPassthrough(this)) {\n      this.passthrough();\n    } else {\n      ctx.pretender.handleRequest(this);\n    }\n  };\n\n  FakeRequest.prototype.passthrough = function passthrough() {\n    if (!this.sendArguments) {\n      throw new Error('You attempted to passthrough a FakeRequest that was never sent. ' + 'Call `.send()` on the original request first');\n    }\n\n    var xhr = createPassthrough(this);\n    xhr.send.apply(xhr, this.sendArguments);\n    return xhr;\n  };\n\n  function createPassthrough(fakeXHR) {\n    // event types to handle on the xhr\n    var evts = ['error', 'timeout', 'abort', 'readystatechange']; // event types to handle on the xhr.upload\n\n    var uploadEvents = []; // properties to copy from the native xhr to fake xhr\n\n    var lifecycleProps = ['readyState', 'responseText', 'response', 'responseXML', 'responseURL', 'status', 'statusText'];\n    var xhr = fakeXHR._passthroughRequest = new ctx.pretender._nativeXMLHttpRequest();\n    xhr.open(fakeXHR.method, fakeXHR.url, fakeXHR.async, fakeXHR.username, fakeXHR.password);\n\n    if (fakeXHR.responseType === 'arraybuffer') {\n      lifecycleProps = ['readyState', 'response', 'status', 'statusText'];\n      xhr.responseType = fakeXHR.responseType;\n    } // use onload if the browser supports it\n\n\n    if ('onload' in xhr) {\n      evts.push('load');\n    } // add progress event for async calls\n    // avoid using progress events for sync calls, they will hang https://bugs.webkit.org/show_bug.cgi?id=40996.\n\n\n    if (fakeXHR.async && fakeXHR.responseType !== 'arraybuffer') {\n      evts.push('progress');\n      uploadEvents.push('progress');\n    } // update `propertyNames` properties from `fromXHR` to `toXHR`\n\n\n    function copyLifecycleProperties(propertyNames, fromXHR, toXHR) {\n      for (var i = 0; i < propertyNames.length; i++) {\n        var prop = propertyNames[i];\n\n        if (prop in fromXHR) {\n          toXHR[prop] = fromXHR[prop];\n        }\n      }\n    } // fire fake event on `eventable`\n\n\n    function dispatchEvent(eventable, eventType, event) {\n      eventable.dispatchEvent(event);\n\n      if (eventable['on' + eventType]) {\n        eventable['on' + eventType](event);\n      }\n    } // set the on- handler on the native xhr for the given eventType\n\n\n    function createHandler(eventType) {\n      xhr['on' + eventType] = function (event) {\n        copyLifecycleProperties(lifecycleProps, xhr, fakeXHR);\n        dispatchEvent(fakeXHR, eventType, event);\n      };\n    } // set the on- handler on the native xhr's `upload` property for\n    // the given eventType\n\n\n    function createUploadHandler(eventType) {\n      if (xhr.upload) {\n        xhr.upload['on' + eventType] = function (event) {\n          dispatchEvent(fakeXHR.upload, eventType, event);\n        };\n      }\n    }\n\n    var i;\n\n    for (i = 0; i < evts.length; i++) {\n      createHandler(evts[i]);\n    }\n\n    for (i = 0; i < uploadEvents.length; i++) {\n      createUploadHandler(uploadEvents[i]);\n    }\n\n    if (fakeXHR.async) {\n      xhr.timeout = fakeXHR.timeout;\n      xhr.withCredentials = fakeXHR.withCredentials;\n    }\n\n    for (var h in fakeXHR.requestHeaders) {\n      xhr.setRequestHeader(h, fakeXHR.requestHeaders[h]);\n    }\n\n    return xhr;\n  }\n\n  FakeRequest.prototype._passthroughCheck = function (method, args) {\n    if (this._passthroughRequest) {\n      return this._passthroughRequest[method].apply(this._passthroughRequest, args);\n    }\n\n    return FakeXMLHttpRequest.prototype[method].apply(this, args);\n  };\n\n  FakeRequest.prototype.abort = function abort() {\n    return this._passthroughCheck('abort', arguments);\n  };\n\n  FakeRequest.prototype.getResponseHeader = function getResponseHeader() {\n    return this._passthroughCheck('getResponseHeader', arguments);\n  };\n\n  FakeRequest.prototype.getAllResponseHeaders = function getAllResponseHeaders() {\n    return this._passthroughCheck('getAllResponseHeaders', arguments);\n  };\n\n  if (ctx.pretender._nativeXMLHttpRequest.prototype._passthroughCheck) {\n    // eslint-disable-next-line no-console\n    console.warn('You created a second Pretender instance while there was already one running. ' + 'Running two Pretender servers at once will lead to unexpected results and will ' + 'be removed entirely in a future major version.' + 'Please call .shutdown() on your instances when you no longer need them to respond.');\n  }\n\n  return FakeRequest;\n}\n\nfunction verbify(verb) {\n  return function (path, handler, async) {\n    return this.register(verb, path, handler, async);\n  };\n}\n\nfunction scheduleProgressEvent(request, startTime, totalTime) {\n  setTimeout(function () {\n    if (!request.aborted && !request.status) {\n      var elapsedTime = new Date().getTime() - startTime.getTime();\n      var progressTotal;\n      var body = request.requestBody;\n\n      if (!body) {\n        progressTotal = 0;\n      } else {\n        // Support Blob, BufferSource, USVString, ArrayBufferView\n        progressTotal = body.byteLength || body.size || body.length || 0;\n      }\n\n      var progressTransmitted = totalTime <= 0 ? 0 : elapsedTime / totalTime * progressTotal; // ProgressEvent expects loaded, total\n      // https://xhr.spec.whatwg.org/#interface-progressevent\n\n      request.upload._progress(true, progressTransmitted, progressTotal);\n\n      request._progress(true, progressTransmitted, progressTotal);\n\n      scheduleProgressEvent(request, startTime, totalTime);\n    }\n  }, 50);\n}\n\nfunction isArray(array) {\n  return Object.prototype.toString.call(array) === '[object Array]';\n}\n\nvar PASSTHROUGH = {};\nPretender.prototype = {\n  get: verbify('GET'),\n  post: verbify('POST'),\n  put: verbify('PUT'),\n  'delete': verbify('DELETE'),\n  patch: verbify('PATCH'),\n  head: verbify('HEAD'),\n  options: verbify('OPTIONS'),\n  map: function (maps) {\n    maps.call(this);\n  },\n  register: function register(verb, url, handler, async) {\n    if (!handler) {\n      throw new Error('The function you tried passing to Pretender to handle ' + verb + ' ' + url + ' is undefined or missing.');\n    }\n\n    handler.numberOfCalls = 0;\n    handler.async = async;\n    this.handlers.push(handler);\n    var registry = this.hosts.forURL(url)[verb];\n    registry.add([{\n      path: parseURL(url).fullpath,\n      handler: handler\n    }]);\n    return handler;\n  },\n  passthrough: PASSTHROUGH,\n  checkPassthrough: function checkPassthrough(request) {\n    var verb = request.method.toUpperCase();\n    var path = parseURL(request.url).fullpath;\n    var recognized = this.hosts.forURL(request.url)[verb].recognize(path);\n    var match = recognized && recognized[0];\n\n    if (match && match.handler === PASSTHROUGH || this.forcePassthrough) {\n      this.passthroughRequests.push(request);\n      this.passthroughRequest(verb, path, request);\n      return true;\n    }\n\n    return false;\n  },\n  handleRequest: function handleRequest(request) {\n    var verb = request.method.toUpperCase();\n    var path = request.url;\n\n    var handler = this._handlerFor(verb, path, request);\n\n    if (handler) {\n      handler.handler.numberOfCalls++;\n      var async = handler.handler.async;\n      this.handledRequests.push(request);\n      var pretender = this;\n\n      var _handleRequest = function (statusHeadersAndBody) {\n        if (!isArray(statusHeadersAndBody)) {\n          var note = 'Remember to `return [status, headers, body];` in your route handler.';\n          throw new Error('Nothing returned by handler for ' + path + '. ' + note);\n        }\n\n        var status = statusHeadersAndBody[0];\n        var headers = pretender.prepareHeaders(statusHeadersAndBody[1]);\n        var body = pretender.prepareBody(statusHeadersAndBody[2], headers);\n        pretender.handleResponse(request, async, function () {\n          request.respond(status, headers, body);\n          pretender.handledRequest(verb, path, request);\n        });\n      };\n\n      try {\n        var result = handler.handler(request);\n\n        if (result && typeof result.then === 'function') {\n          // `result` is a promise, resolve it\n          result.then(function (resolvedResult) {\n            _handleRequest(resolvedResult);\n          });\n        } else {\n          _handleRequest(result);\n        }\n      } catch (error) {\n        this.erroredRequest(verb, path, request, error);\n        this.resolve(request);\n      }\n    } else {\n      if (!this.disableUnhandled) {\n        this.unhandledRequests.push(request);\n        this.unhandledRequest(verb, path, request);\n      }\n    }\n  },\n  handleResponse: function handleResponse(request, strategy, callback) {\n    var delay = typeof strategy === 'function' ? strategy() : strategy;\n    delay = typeof delay === 'boolean' || typeof delay === 'number' ? delay : 0;\n\n    if (delay === false) {\n      callback();\n    } else {\n      var pretender = this;\n      pretender.requestReferences.push({\n        request: request,\n        callback: callback\n      });\n\n      if (delay !== true) {\n        scheduleProgressEvent(request, new Date(), delay);\n        setTimeout(function () {\n          pretender.resolve(request);\n        }, delay);\n      }\n    }\n  },\n  resolve: function resolve(request) {\n    for (var i = 0, len = this.requestReferences.length; i < len; i++) {\n      var res = this.requestReferences[i];\n\n      if (res.request === request) {\n        res.callback();\n        this.requestReferences.splice(i, 1);\n        break;\n      }\n    }\n  },\n  requiresManualResolution: function (verb, path) {\n    var handler = this._handlerFor(verb.toUpperCase(), path, {});\n\n    if (!handler) {\n      return false;\n    }\n\n    var async = handler.handler.async;\n    return typeof async === 'function' ? async() === true : async === true;\n  },\n  prepareBody: function (body) {\n    return body;\n  },\n  prepareHeaders: function (headers) {\n    return headers;\n  },\n  handledRequest: function ()\n  /* verb, path, request */\n  {},\n  passthroughRequest: function ()\n  /* verb, path, request */\n  {},\n  unhandledRequest: function (verb, path\n  /*, request */\n  ) {\n    throw new Error('Pretender intercepted ' + verb + ' ' + path + ' but no handler was defined for this type of request');\n  },\n  erroredRequest: function (verb, path, request, error) {\n    error.message = 'Pretender intercepted ' + verb + ' ' + path + ' but encountered an error: ' + error.message;\n    throw error;\n  },\n  _handlerFor: function (verb, url, request) {\n    var registry = this.hosts.forURL(url)[verb];\n    var matches = registry.recognize(parseURL(url).fullpath);\n    var match = matches ? matches[0] : null;\n\n    if (match) {\n      request.params = match.params;\n      request.queryParams = matches.queryParams;\n    }\n\n    return match;\n  },\n  shutdown: function shutdown() {\n    self.XMLHttpRequest = this._nativeXMLHttpRequest;\n\n    this._fetchProps.forEach(function (name) {\n      self[name] = this['_native' + name];\n    }, this);\n\n    this.ctx.pretender = undefined; // 'stop' the server\n\n    this.running = false;\n  }\n};\nPretender.parseURL = parseURL;\nPretender.Hosts = Hosts;\nPretender.Registry = Registry;\nexport default Pretender;","map":null,"metadata":{},"sourceType":"module"}