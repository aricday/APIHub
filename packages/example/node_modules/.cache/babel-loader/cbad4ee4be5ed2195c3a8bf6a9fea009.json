{"ast":null,"code":"module.exports =\n/******/\nfunction (modules) {\n  // webpackBootstrap\n\n  /******/\n  // The module cache\n\n  /******/\n  var installedModules = {};\n  /******/\n\n  /******/\n  // The require function\n\n  /******/\n\n  function __webpack_require__(moduleId) {\n    /******/\n\n    /******/\n    // Check if module is in cache\n\n    /******/\n    if (installedModules[moduleId]) {\n      /******/\n      return installedModules[moduleId].exports;\n      /******/\n    }\n    /******/\n    // Create a new module (and put it into the cache)\n\n    /******/\n\n\n    var module = installedModules[moduleId] = {\n      /******/\n      i: moduleId,\n\n      /******/\n      l: false,\n\n      /******/\n      exports: {}\n      /******/\n\n    };\n    /******/\n\n    /******/\n    // Execute the module function\n\n    /******/\n\n    modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n    /******/\n\n    /******/\n    // Flag the module as loaded\n\n    /******/\n\n    module.l = true;\n    /******/\n\n    /******/\n    // Return the exports of the module\n\n    /******/\n\n    return module.exports;\n    /******/\n  }\n  /******/\n\n  /******/\n\n  /******/\n  // expose the modules object (__webpack_modules__)\n\n  /******/\n\n\n  __webpack_require__.m = modules;\n  /******/\n\n  /******/\n  // expose the module cache\n\n  /******/\n\n  __webpack_require__.c = installedModules;\n  /******/\n\n  /******/\n  // define getter function for harmony exports\n\n  /******/\n\n  __webpack_require__.d = function (exports, name, getter) {\n    /******/\n    if (!__webpack_require__.o(exports, name)) {\n      /******/\n      Object.defineProperty(exports, name, {\n        enumerable: true,\n        get: getter\n      });\n      /******/\n    }\n    /******/\n\n  };\n  /******/\n\n  /******/\n  // define __esModule on exports\n\n  /******/\n\n\n  __webpack_require__.r = function (exports) {\n    /******/\n    if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n      /******/\n      Object.defineProperty(exports, Symbol.toStringTag, {\n        value: 'Module'\n      });\n      /******/\n    }\n    /******/\n\n\n    Object.defineProperty(exports, '__esModule', {\n      value: true\n    });\n    /******/\n  };\n  /******/\n\n  /******/\n  // create a fake namespace object\n\n  /******/\n  // mode & 1: value is a module id, require it\n\n  /******/\n  // mode & 2: merge all properties of value into the ns\n\n  /******/\n  // mode & 4: return value when already ns object\n\n  /******/\n  // mode & 8|1: behave like require\n\n  /******/\n\n\n  __webpack_require__.t = function (value, mode) {\n    /******/\n    if (mode & 1) value = __webpack_require__(value);\n    /******/\n\n    if (mode & 8) return value;\n    /******/\n\n    if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;\n    /******/\n\n    var ns = Object.create(null);\n    /******/\n\n    __webpack_require__.r(ns);\n    /******/\n\n\n    Object.defineProperty(ns, 'default', {\n      enumerable: true,\n      value: value\n    });\n    /******/\n\n    if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {\n      return value[key];\n    }.bind(null, key));\n    /******/\n\n    return ns;\n    /******/\n  };\n  /******/\n\n  /******/\n  // getDefaultExport function for compatibility with non-harmony modules\n\n  /******/\n\n\n  __webpack_require__.n = function (module) {\n    /******/\n    var getter = module && module.__esModule ?\n    /******/\n    function getDefault() {\n      return module['default'];\n    } :\n    /******/\n    function getModuleExports() {\n      return module;\n    };\n    /******/\n\n    __webpack_require__.d(getter, 'a', getter);\n    /******/\n\n\n    return getter;\n    /******/\n  };\n  /******/\n\n  /******/\n  // Object.prototype.hasOwnProperty.call\n\n  /******/\n\n\n  __webpack_require__.o = function (object, property) {\n    return Object.prototype.hasOwnProperty.call(object, property);\n  };\n  /******/\n\n  /******/\n  // __webpack_public_path__\n\n  /******/\n\n\n  __webpack_require__.p = \"\";\n  /******/\n\n  /******/\n\n  /******/\n  // Load entry module and return exports\n\n  /******/\n\n  return __webpack_require__(__webpack_require__.s = 45);\n  /******/\n}(\n/************************************************************************/\n\n/******/\n[\n/* 0 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/keys\");\n  /***/\n},\n/* 1 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/array/is-array\");\n  /***/\n},\n/* 2 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/typeof\");\n  /***/\n},\n/* 3 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/assign\");\n  /***/\n},\n/* 4 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/regenerator\");\n  /***/\n},\n/* 5 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\");\n  /***/\n},\n/* 6 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\");\n  /***/\n},\n/* 7 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\");\n  /***/\n},\n/* 8 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/defineProperty\");\n  /***/\n},\n/* 9 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/define-property\");\n  /***/\n},\n/* 10 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/define-properties\");\n  /***/\n},\n/* 11 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/json/stringify\");\n  /***/\n},\n/* 12 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"url\");\n  /***/\n},\n/* 13 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/toConsumableArray\");\n  /***/\n},\n/* 14 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/promise\");\n  /***/\n},\n/* 15 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/assign\");\n  /***/\n},\n/* 16 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/get\");\n  /***/\n},\n/* 17 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/asyncToGenerator\");\n  /***/\n},\n/* 18 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"fast-json-patch\");\n  /***/\n},\n/* 19 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"btoa\");\n  /***/\n},\n/* 20 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/startsWith\");\n  /***/\n},\n/* 21 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/get-iterator\");\n  /***/\n},\n/* 22 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/slicedToArray\");\n  /***/\n},\n/* 23 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"js-yaml\");\n  /***/\n},\n/* 24 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/classCallCheck\");\n  /***/\n},\n/* 25 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/createClass\");\n  /***/\n},\n/* 26 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"qs\");\n  /***/\n},\n/* 27 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/object/create\");\n  /***/\n},\n/* 28 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"querystring-browser\");\n  /***/\n},\n/* 29 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/isObject\");\n  /***/\n},\n/* 30 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"buffer/\");\n  /***/\n},\n/* 31 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/isString\");\n  /***/\n},\n/* 32 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/find\");\n  /***/\n},\n/* 33 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"deep-extend\");\n  /***/\n},\n/* 34 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@kyleshockey/object-assign-deep\");\n  /***/\n},\n/* 35 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/core-js/weak-map\");\n  /***/\n},\n/* 36 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"cross-fetch\");\n  /***/\n},\n/* 37 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"traverse\");\n  /***/\n},\n/* 38 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/pick\");\n  /***/\n},\n/* 39 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"@babel/runtime-corejs2/helpers/objectWithoutProperties\");\n  /***/\n},\n/* 40 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/isPlainObject\");\n  /***/\n},\n/* 41 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/isArray\");\n  /***/\n},\n/* 42 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"cookie\");\n  /***/\n},\n/* 43 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"utf8-bytes\");\n  /***/\n},\n/* 44 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"utfstring\");\n  /***/\n},\n/* 45 */\n\n/***/\nfunction (module, exports, __webpack_require__) {\n  module.exports = __webpack_require__(50);\n  /***/\n},\n/* 46 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"lodash/cloneDeep\");\n  /***/\n},\n/* 47 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"cross-fetch/polyfill\");\n  /***/\n},\n/* 48 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"isomorphic-form-data\");\n  /***/\n},\n/* 49 */\n\n/***/\nfunction (module, exports) {\n  module.exports = require(\"encode-3986\");\n  /***/\n},\n/* 50 */\n\n/***/\nfunction (module, __webpack_exports__, __webpack_require__) {\n  \"use strict\";\n\n  __webpack_require__.r(__webpack_exports__);\n\n  var oas3_parameter_builders_namespaceObject = {};\n\n  __webpack_require__.r(oas3_parameter_builders_namespaceObject);\n\n  __webpack_require__.d(oas3_parameter_builders_namespaceObject, \"path\", function () {\n    return parameter_builders_path;\n  });\n\n  __webpack_require__.d(oas3_parameter_builders_namespaceObject, \"query\", function () {\n    return parameter_builders_query;\n  });\n\n  __webpack_require__.d(oas3_parameter_builders_namespaceObject, \"header\", function () {\n    return parameter_builders_header;\n  });\n\n  __webpack_require__.d(oas3_parameter_builders_namespaceObject, \"cookie\", function () {\n    return cookie;\n  }); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/define-property\"\n\n\n  var define_property_ = __webpack_require__(9);\n\n  var define_property_default =\n  /*#__PURE__*/\n  __webpack_require__.n(define_property_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/define-properties\"\n\n\n  var define_properties_ = __webpack_require__(10);\n\n  var define_properties_default =\n  /*#__PURE__*/\n  __webpack_require__.n(define_properties_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptors\"\n\n\n  var get_own_property_descriptors_ = __webpack_require__(5);\n\n  var get_own_property_descriptors_default =\n  /*#__PURE__*/\n  __webpack_require__.n(get_own_property_descriptors_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/get-own-property-descriptor\"\n\n\n  var get_own_property_descriptor_ = __webpack_require__(6);\n\n  var get_own_property_descriptor_default =\n  /*#__PURE__*/\n  __webpack_require__.n(get_own_property_descriptor_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/get-own-property-symbols\"\n\n\n  var get_own_property_symbols_ = __webpack_require__(7);\n\n  var get_own_property_symbols_default =\n  /*#__PURE__*/\n  __webpack_require__.n(get_own_property_symbols_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/keys\"\n\n\n  var keys_ = __webpack_require__(0);\n\n  var keys_default =\n  /*#__PURE__*/\n  __webpack_require__.n(keys_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/defineProperty\"\n\n\n  var defineProperty_ = __webpack_require__(8);\n\n  var defineProperty_default =\n  /*#__PURE__*/\n  __webpack_require__.n(defineProperty_); // EXTERNAL MODULE: external \"lodash/cloneDeep\"\n\n\n  var cloneDeep_ = __webpack_require__(46); // EXTERNAL MODULE: external \"lodash/assign\"\n\n\n  var assign_ = __webpack_require__(15);\n\n  var assign_default =\n  /*#__PURE__*/\n  __webpack_require__.n(assign_); // EXTERNAL MODULE: external \"lodash/startsWith\"\n\n\n  var startsWith_ = __webpack_require__(20);\n\n  var startsWith_default =\n  /*#__PURE__*/\n  __webpack_require__.n(startsWith_); // EXTERNAL MODULE: external \"url\"\n\n\n  var external_url_ = __webpack_require__(12);\n\n  var external_url_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_url_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/regenerator\"\n\n\n  var regenerator_ = __webpack_require__(4);\n\n  var regenerator_default =\n  /*#__PURE__*/\n  __webpack_require__.n(regenerator_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/slicedToArray\"\n\n\n  var slicedToArray_ = __webpack_require__(22);\n\n  var slicedToArray_default =\n  /*#__PURE__*/\n  __webpack_require__.n(slicedToArray_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/json/stringify\"\n\n\n  var stringify_ = __webpack_require__(11);\n\n  var stringify_default =\n  /*#__PURE__*/\n  __webpack_require__.n(stringify_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/typeof\"\n\n\n  var typeof_ = __webpack_require__(2);\n\n  var typeof_default =\n  /*#__PURE__*/\n  __webpack_require__.n(typeof_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/array/is-array\"\n\n\n  var is_array_ = __webpack_require__(1);\n\n  var is_array_default =\n  /*#__PURE__*/\n  __webpack_require__.n(is_array_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/asyncToGenerator\"\n\n\n  var asyncToGenerator_ = __webpack_require__(17);\n\n  var asyncToGenerator_default =\n  /*#__PURE__*/\n  __webpack_require__.n(asyncToGenerator_); // EXTERNAL MODULE: external \"cross-fetch/polyfill\"\n\n\n  var polyfill_ = __webpack_require__(47); // EXTERNAL MODULE: external \"qs\"\n\n\n  var external_qs_ = __webpack_require__(26);\n\n  var external_qs_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_qs_); // EXTERNAL MODULE: external \"js-yaml\"\n\n\n  var external_js_yaml_ = __webpack_require__(23);\n\n  var external_js_yaml_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_js_yaml_); // EXTERNAL MODULE: external \"lodash/isString\"\n\n\n  var isString_ = __webpack_require__(31);\n\n  var isString_default =\n  /*#__PURE__*/\n  __webpack_require__.n(isString_); // CONCATENATED MODULE: ./src/http.js\n\n  /* global fetch */\n  // For testing\n\n\n  var http_self = {\n    serializeRes: serializeRes,\n    mergeInQueryOrForm: mergeInQueryOrForm // Handles fetch-like syntax and the case where there is only one object passed-in\n    // (which will have the URL as a property). Also serilizes the response.\n\n  };\n\n  function http_http(_x) {\n    return _http.apply(this, arguments);\n  } // exported for testing\n\n\n  function _http() {\n    _http = asyncToGenerator_default()(\n    /*#__PURE__*/\n    regenerator_default.a.mark(function _callee(url) {\n      var request,\n          contentType,\n          res,\n          error,\n          _error,\n          _args = arguments;\n\n      return regenerator_default.a.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              request = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n\n              if (typeof_default()(url) === 'object') {\n                request = url;\n                url = request.url;\n              }\n\n              request.headers = request.headers || {}; // Serializes query, for convenience\n              // Should be the last thing we do, as its hard to mutate the URL with\n              // the search string, but much easier to manipulate the req.query object\n\n              http_self.mergeInQueryOrForm(request); // Newlines in header values cause weird error messages from `window.fetch`,\n              // so let's massage them out.\n              // Context: https://stackoverflow.com/a/50709178\n\n              if (request.headers) {\n                keys_default()(request.headers).forEach(function (headerName) {\n                  var value = request.headers[headerName];\n\n                  if (typeof value === 'string') {\n                    request.headers[headerName] = value.replace(/\\n+/g, ' ');\n                  }\n                });\n              } // Wait for the request interceptor, if it was provided\n              // WARNING: don't put anything between this and the request firing unless\n              // you have a good reason!\n\n\n              if (!request.requestInterceptor) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 8;\n              return request.requestInterceptor(request);\n\n            case 8:\n              _context.t0 = _context.sent;\n\n              if (_context.t0) {\n                _context.next = 11;\n                break;\n              }\n\n              _context.t0 = request;\n\n            case 11:\n              request = _context.t0;\n\n            case 12:\n              // for content-type=multipart\\/form-data remove content-type from request before fetch\n              // so that correct one with `boundary` is set\n              contentType = request.headers['content-type'] || request.headers['Content-Type'];\n\n              if (/multipart\\/form-data/i.test(contentType)) {\n                delete request.headers['content-type'];\n                delete request.headers['Content-Type'];\n              } // eslint-disable-next-line no-undef\n\n\n              _context.prev = 14;\n              _context.next = 17;\n              return (request.userFetch || fetch)(request.url, request);\n\n            case 17:\n              res = _context.sent;\n              _context.next = 20;\n              return http_self.serializeRes(res, url, request);\n\n            case 20:\n              res = _context.sent;\n\n              if (!request.responseInterceptor) {\n                _context.next = 28;\n                break;\n              }\n\n              _context.next = 24;\n              return request.responseInterceptor(res);\n\n            case 24:\n              _context.t1 = _context.sent;\n\n              if (_context.t1) {\n                _context.next = 27;\n                break;\n              }\n\n              _context.t1 = res;\n\n            case 27:\n              res = _context.t1;\n\n            case 28:\n              _context.next = 38;\n              break;\n\n            case 30:\n              _context.prev = 30;\n              _context.t2 = _context[\"catch\"](14);\n\n              if (res) {\n                _context.next = 34;\n                break;\n              }\n\n              throw _context.t2;\n\n            case 34:\n              error = new Error(res.statusText);\n              error.statusCode = error.status = res.status;\n              error.responseError = _context.t2;\n              throw error;\n\n            case 38:\n              if (res.ok) {\n                _context.next = 43;\n                break;\n              }\n\n              _error = new Error(res.statusText);\n              _error.statusCode = _error.status = res.status;\n              _error.response = res;\n              throw _error;\n\n            case 43:\n              return _context.abrupt(\"return\", res);\n\n            case 44:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[14, 30]]);\n    }));\n    return _http.apply(this, arguments);\n  }\n\n  var shouldDownloadAsText = function shouldDownloadAsText() {\n    var contentType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    return /(json|xml|yaml|text)\\b/.test(contentType);\n  };\n\n  function parseBody(body, contentType) {\n    if (contentType && (contentType.indexOf('application/json') === 0 || contentType.indexOf('+json') > 0)) {\n      return JSON.parse(body);\n    }\n\n    return external_js_yaml_default.a.safeLoad(body);\n  } // Serialize the response, returns a promise with headers and the body part of the hash\n\n\n  function serializeRes(oriRes, url) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref$loadSpec = _ref.loadSpec,\n        loadSpec = _ref$loadSpec === void 0 ? false : _ref$loadSpec;\n\n    var res = {\n      ok: oriRes.ok,\n      url: oriRes.url || url,\n      status: oriRes.status,\n      statusText: oriRes.statusText,\n      headers: serializeHeaders(oriRes.headers)\n    };\n    var contentType = res.headers['content-type'];\n    var useText = loadSpec || shouldDownloadAsText(contentType); // Note: Response.blob not implemented in node-fetch 1.  Use buffer instead.\n\n    var getBody = useText ? oriRes.text : oriRes.blob || oriRes.buffer;\n    return getBody.call(oriRes).then(function (body) {\n      res.text = body;\n      res.data = body;\n\n      if (useText) {\n        try {\n          var obj = parseBody(body, contentType);\n          res.body = obj;\n          res.obj = obj;\n        } catch (e) {\n          res.parseError = e;\n        }\n      }\n\n      return res;\n    });\n  } // Serialize headers into a hash, where mutliple-headers result in an array.\n  //\n  // eg: Cookie: one\n  //     Cookie: two\n  //  =  { Cookie: [ \"one\", \"two\" ]\n\n\n  function serializeHeaders() {\n    var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var obj = {}; // Iterate over headers, making multiple-headers into an array\n\n    if (typeof headers.forEach === 'function') {\n      headers.forEach(function (headerValue, header) {\n        if (obj[header] !== undefined) {\n          obj[header] = is_array_default()(obj[header]) ? obj[header] : [obj[header]];\n          obj[header].push(headerValue);\n        } else {\n          obj[header] = headerValue;\n        }\n      });\n      return obj;\n    }\n\n    return obj;\n  }\n\n  function http_isFile(obj, navigatorObj) {\n    if (!navigatorObj && typeof navigator !== 'undefined') {\n      // eslint-disable-next-line no-undef\n      navigatorObj = navigator;\n    }\n\n    if (navigatorObj && navigatorObj.product === 'ReactNative') {\n      if (obj && typeof_default()(obj) === 'object' && typeof obj.uri === 'string') {\n        return true;\n      }\n\n      return false;\n    }\n\n    if (typeof File !== 'undefined') {\n      // eslint-disable-next-line no-undef\n      return obj instanceof File;\n    }\n\n    return obj !== null && typeof_default()(obj) === 'object' && typeof obj.pipe === 'function';\n  }\n\n  function formatValue(input, skipEncoding) {\n    var collectionFormat = input.collectionFormat,\n        allowEmptyValue = input.allowEmptyValue; // `input` can be string in OAS3 contexts\n\n    var value = typeof_default()(input) === 'object' ? input.value : input;\n    var SEPARATORS = {\n      csv: ',',\n      ssv: '%20',\n      tsv: '%09',\n      pipes: '|'\n    };\n\n    if (typeof value === 'undefined' && allowEmptyValue) {\n      return '';\n    }\n\n    if (http_isFile(value) || typeof value === 'boolean') {\n      return value;\n    }\n\n    var encodeFn = encodeURIComponent;\n\n    if (skipEncoding) {\n      if (isString_default()(value)) encodeFn = function encodeFn(str) {\n        return str;\n      };else encodeFn = function encodeFn(obj) {\n        return stringify_default()(obj);\n      };\n    }\n\n    if (typeof_default()(value) === 'object' && !is_array_default()(value)) {\n      return '';\n    }\n\n    if (!is_array_default()(value)) {\n      return encodeFn(value);\n    }\n\n    if (is_array_default()(value) && !collectionFormat) {\n      return value.map(encodeFn).join(',');\n    }\n\n    if (collectionFormat === 'multi') {\n      return value.map(encodeFn);\n    }\n\n    return value.map(encodeFn).join(SEPARATORS[collectionFormat]);\n  } // Encodes an object using appropriate serializer.\n\n\n  function encodeFormOrQuery(data) {\n    /**\n                                            * Encode parameter names and values\n                                            * @param {Object} result - parameter names and values\n                                            * @param {string} parameterName - Parameter name\n                                            * @return {object} encoded parameter names and values\n                                            */\n    var encodedQuery = keys_default()(data).reduce(function (result, parameterName) {\n      var isObject = function isObject(a) {\n        return a && typeof_default()(a) === 'object';\n      };\n\n      var paramValue = data[parameterName];\n      var skipEncoding = !!paramValue.skipEncoding;\n      var encodedParameterName = skipEncoding ? parameterName : encodeURIComponent(parameterName);\n      var notArray = isObject(paramValue) && !is_array_default()(paramValue);\n      result[encodedParameterName] = formatValue(notArray ? paramValue : {\n        value: paramValue\n      }, skipEncoding);\n      return result;\n    }, {});\n    return external_qs_default.a.stringify(encodedQuery, {\n      encode: false,\n      indices: false\n    }) || '';\n  } // If the request has a `query` object, merge it into the request.url, and delete the object\n\n\n  function mergeInQueryOrForm() {\n    var req = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var _req$url = req.url,\n        url = _req$url === void 0 ? '' : _req$url,\n        query = req.query,\n        form = req.form;\n\n    var joinSearch = function joinSearch() {\n      for (var _len = arguments.length, strs = new Array(_len), _key = 0; _key < _len; _key++) {\n        strs[_key] = arguments[_key];\n      }\n\n      var search = strs.filter(function (a) {\n        return a;\n      }).join('&'); // Only truthy value\n\n      return search ? \"?\".concat(search) : ''; // Only add '?' if there is a str\n    };\n\n    if (form) {\n      var hasFile = keys_default()(form).some(function (key) {\n        return http_isFile(form[key].value);\n      });\n      var contentType = req.headers['content-type'] || req.headers['Content-Type'];\n\n      if (hasFile || /multipart\\/form-data/i.test(contentType)) {\n        var FormData = __webpack_require__(48); // eslint-disable-line global-require\n\n\n        req.body = new FormData();\n        keys_default()(form).forEach(function (key) {\n          req.body.append(key, formatValue(form[key], true));\n        });\n      } else {\n        req.body = encodeFormOrQuery(form);\n      }\n\n      delete req.form;\n    }\n\n    if (query) {\n      var _url$split = url.split('?'),\n          _url$split2 = slicedToArray_default()(_url$split, 2),\n          baseUrl = _url$split2[0],\n          oriSearch = _url$split2[1];\n\n      var newStr = '';\n\n      if (oriSearch) {\n        var oriQuery = external_qs_default.a.parse(oriSearch);\n        var keysToRemove = keys_default()(query);\n        keysToRemove.forEach(function (key) {\n          return delete oriQuery[key];\n        });\n        newStr = external_qs_default.a.stringify(oriQuery, {\n          encode: true\n        });\n      }\n\n      var finalStr = joinSearch(newStr, encodeFormOrQuery(query));\n      req.url = baseUrl + finalStr;\n      delete req.query;\n    }\n\n    return req;\n  } // Wrap a http function ( there are otherways to do this, conisder this deprecated )\n\n\n  function makeHttp(httpFn, preFetch, postFetch) {\n    postFetch = postFetch || function (a) {\n      return a;\n    };\n\n    preFetch = preFetch || function (a) {\n      return a;\n    };\n\n    return function (req) {\n      if (typeof req === 'string') {\n        req = {\n          url: req\n        };\n      }\n\n      http_self.mergeInQueryOrForm(req);\n      req = preFetch(req);\n      return postFetch(httpFn(req));\n    };\n  } // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/promise\"\n\n\n  var promise_ = __webpack_require__(14);\n\n  var promise_default =\n  /*#__PURE__*/\n  __webpack_require__.n(promise_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/get-iterator\"\n\n\n  var get_iterator_ = __webpack_require__(21);\n\n  var get_iterator_default =\n  /*#__PURE__*/\n  __webpack_require__.n(get_iterator_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/create\"\n\n\n  var create_ = __webpack_require__(27);\n\n  var create_default =\n  /*#__PURE__*/\n  __webpack_require__.n(create_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/object/assign\"\n\n\n  var object_assign_ = __webpack_require__(3);\n\n  var object_assign_default =\n  /*#__PURE__*/\n  __webpack_require__.n(object_assign_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/classCallCheck\"\n\n\n  var classCallCheck_ = __webpack_require__(24);\n\n  var classCallCheck_default =\n  /*#__PURE__*/\n  __webpack_require__.n(classCallCheck_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/createClass\"\n\n\n  var createClass_ = __webpack_require__(25);\n\n  var createClass_default =\n  /*#__PURE__*/\n  __webpack_require__.n(createClass_); // EXTERNAL MODULE: external \"lodash/find\"\n\n\n  var find_ = __webpack_require__(32);\n\n  var find_default =\n  /*#__PURE__*/\n  __webpack_require__.n(find_); // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/toConsumableArray\"\n\n\n  var toConsumableArray_ = __webpack_require__(13);\n\n  var toConsumableArray_default =\n  /*#__PURE__*/\n  __webpack_require__.n(toConsumableArray_); // EXTERNAL MODULE: external \"fast-json-patch\"\n\n\n  var external_fast_json_patch_ = __webpack_require__(18);\n\n  var external_fast_json_patch_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_fast_json_patch_); // EXTERNAL MODULE: external \"deep-extend\"\n\n\n  var external_deep_extend_ = __webpack_require__(33);\n\n  var external_deep_extend_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_deep_extend_); // EXTERNAL MODULE: external \"@kyleshockey/object-assign-deep\"\n\n\n  var object_assign_deep_ = __webpack_require__(34);\n\n  var object_assign_deep_default =\n  /*#__PURE__*/\n  __webpack_require__.n(object_assign_deep_); // CONCATENATED MODULE: ./src/specmap/lib/index.js\n\n  /* harmony default export */\n\n\n  var lib = {\n    add: add,\n    replace: replace,\n    remove: remove,\n    merge: merge,\n    mergeDeep: mergeDeep,\n    context: context,\n    getIn: getIn,\n    applyPatch: applyPatch,\n    parentPathMatch: parentPathMatch,\n    flatten: flatten,\n    fullyNormalizeArray: fullyNormalizeArray,\n    normalizeArray: lib_normalizeArray,\n    isPromise: isPromise,\n    forEachNew: forEachNew,\n    forEachNewPrimitive: forEachNewPrimitive,\n    isJsonPatch: isJsonPatch,\n    isContextPatch: isContextPatch,\n    isPatch: isPatch,\n    isMutation: isMutation,\n    isAdditiveMutation: isAdditiveMutation,\n    isGenerator: isGenerator,\n    isFunction: isFunction,\n    isObject: lib_isObject,\n    isError: isError\n  };\n\n  function applyPatch(obj, patch, opts) {\n    opts = opts || {};\n    patch = object_assign_default()({}, patch, {\n      path: patch.path && normalizeJSONPath(patch.path)\n    });\n\n    if (patch.op === 'merge') {\n      var newValue = getInByJsonPath(obj, patch.path);\n      object_assign_default()(newValue, patch.value);\n      external_fast_json_patch_default.a.applyPatch(obj, [replace(patch.path, newValue)]);\n    } else if (patch.op === 'mergeDeep') {\n      var currentValue = getInByJsonPath(obj, patch.path); // Iterate the properties of the patch\n\n      for (var prop in patch.value) {\n        var propVal = patch.value[prop];\n        var isArray = is_array_default()(propVal);\n\n        if (isArray) {\n          // deepExtend doesn't merge arrays, so we will do it manually\n          var existing = currentValue[prop] || [];\n          currentValue[prop] = existing.concat(propVal);\n        } else if (lib_isObject(propVal) && !isArray) {\n          // If it's an object, iterate it's keys and merge\n          // if there are conflicting keys, merge deep, otherwise shallow merge\n          var currentObj = object_assign_default()({}, currentValue[prop]);\n\n          for (var key in propVal) {\n            if (Object.prototype.hasOwnProperty.call(currentObj, key)) {\n              // if there is a single conflicting key, just deepExtend the entire value\n              // and break from the loop (since all future keys are also merged)\n              // We do this because we can't deepExtend two primitives\n              // (currentObj[key] & propVal[key] may be primitives).\n              //\n              // we also deeply assign here, since we aren't in control of\n              // how deepExtend affects existing nested objects\n              currentObj = external_deep_extend_default()(object_assign_deep_default()({}, currentObj), propVal);\n              break;\n            } else {\n              object_assign_default()(currentObj, defineProperty_default()({}, key, propVal[key]));\n            }\n          }\n\n          currentValue[prop] = currentObj;\n        } else {\n          // It's a primitive, just replace existing\n          currentValue[prop] = propVal;\n        }\n      }\n    } else if (patch.op === 'add' && patch.path === '' && lib_isObject(patch.value)) {\n      // { op: 'add', path: '', value: { a: 1, b: 2 }}\n      // has no effect: json patch refuses to do anything.\n      // so let's break that patch down into a set of patches,\n      // one for each key in the intended root value.\n      var patches = keys_default()(patch.value).reduce(function (arr, key) {\n        arr.push({\n          op: 'add',\n          path: \"/\".concat(normalizeJSONPath(key)),\n          value: patch.value[key]\n        });\n        return arr;\n      }, []);\n      external_fast_json_patch_default.a.applyPatch(obj, patches);\n    } else if (patch.op === 'replace' && patch.path === '') {\n      var value = patch.value;\n\n      if (opts.allowMetaPatches && patch.meta && isAdditiveMutation(patch) && (is_array_default()(patch.value) || lib_isObject(patch.value))) {\n        value = object_assign_default()({}, value, patch.meta);\n      }\n\n      obj = value;\n    } else {\n      external_fast_json_patch_default.a.applyPatch(obj, [patch]); // Attach metadata to the resulting value.\n\n      if (opts.allowMetaPatches && patch.meta && isAdditiveMutation(patch) && (is_array_default()(patch.value) || lib_isObject(patch.value))) {\n        var _currentValue = getInByJsonPath(obj, patch.path);\n\n        var _newValue = object_assign_default()({}, _currentValue, patch.meta);\n\n        external_fast_json_patch_default.a.applyPatch(obj, [replace(patch.path, _newValue)]);\n      }\n    }\n\n    return obj;\n  }\n\n  function normalizeJSONPath(path) {\n    if (is_array_default()(path)) {\n      if (path.length < 1) {\n        return '';\n      }\n\n      return '/' + path.map(function (item) {\n        // eslint-disable-line prefer-template\n        return (item + '').replace(/~/g, '~0').replace(/\\//g, '~1'); // eslint-disable-line prefer-template\n      }).join('/');\n    }\n\n    return path;\n  } // =========================\n  // JSON-Patch Wrappers\n  // =========================\n\n\n  function add(path, value) {\n    return {\n      op: 'add',\n      path: path,\n      value: value\n    };\n  }\n\n  function lib_get(path) {\n    return {\n      op: '_get',\n      path: path\n    };\n  }\n\n  function replace(path, value, meta) {\n    return {\n      op: 'replace',\n      path: path,\n      value: value,\n      meta: meta\n    };\n  }\n\n  function remove(path, value) {\n    return {\n      op: 'remove',\n      path: path\n    };\n  } // Custom wrappers\n\n\n  function merge(path, value) {\n    return {\n      type: 'mutation',\n      op: 'merge',\n      path: path,\n      value: value\n    };\n  } // Custom wrappers\n\n\n  function mergeDeep(path, value) {\n    return {\n      type: 'mutation',\n      op: 'mergeDeep',\n      path: path,\n      value: value\n    };\n  }\n\n  function context(path, value) {\n    return {\n      type: 'context',\n      path: path,\n      value: value\n    };\n  } // =========================\n  // Iterators\n  // =========================\n\n\n  function forEachNew(mutations, fn) {\n    try {\n      return forEachNewPatch(mutations, forEach, fn);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function forEachNewPrimitive(mutations, fn) {\n    try {\n      return forEachNewPatch(mutations, forEachPrimitive, fn);\n    } catch (e) {\n      return e;\n    }\n  }\n\n  function forEachNewPatch(mutations, fn, callback) {\n    var res = mutations.filter(isAdditiveMutation).map(function (mutation) {\n      return fn(mutation.value, callback, mutation.path);\n    }) || [];\n    var flat = flatten(res);\n    var clean = cleanArray(flat);\n    return clean;\n  }\n\n  function forEachPrimitive(obj, fn, basePath) {\n    basePath = basePath || [];\n\n    if (is_array_default()(obj)) {\n      return obj.map(function (val, key) {\n        return forEachPrimitive(val, fn, basePath.concat(key));\n      });\n    }\n\n    if (lib_isObject(obj)) {\n      return keys_default()(obj).map(function (key) {\n        return forEachPrimitive(obj[key], fn, basePath.concat(key));\n      });\n    }\n\n    return fn(obj, basePath[basePath.length - 1], basePath);\n  }\n\n  function forEach(obj, fn, basePath) {\n    basePath = basePath || [];\n    var results = [];\n\n    if (basePath.length > 0) {\n      var newResults = fn(obj, basePath[basePath.length - 1], basePath);\n\n      if (newResults) {\n        results = results.concat(newResults);\n      }\n    }\n\n    if (is_array_default()(obj)) {\n      var arrayResults = obj.map(function (val, key) {\n        return forEach(val, fn, basePath.concat(key));\n      });\n\n      if (arrayResults) {\n        results = results.concat(arrayResults);\n      }\n    } else if (lib_isObject(obj)) {\n      var moreResults = keys_default()(obj).map(function (key) {\n        return forEach(obj[key], fn, basePath.concat(key));\n      });\n\n      if (moreResults) {\n        results = results.concat(moreResults);\n      }\n    }\n\n    results = flatten(results);\n    return results;\n  } // =========================\n  // Paths\n  // =========================\n\n\n  function parentPathMatch(path, arr) {\n    if (!is_array_default()(arr)) {\n      return false;\n    }\n\n    for (var i = 0, len = arr.length; i < len; i++) {\n      if (arr[i] !== path[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  function getIn(obj, path) {\n    return path.reduce(function (val, token) {\n      if (typeof token !== 'undefined' && val) {\n        return val[token];\n      }\n\n      return val;\n    }, obj);\n  } // =========================\n  // Array\n  // =========================\n\n\n  function fullyNormalizeArray(arr) {\n    return cleanArray(flatten(lib_normalizeArray(arr)));\n  }\n\n  function lib_normalizeArray(arr) {\n    return is_array_default()(arr) ? arr : [arr];\n  }\n\n  function flatten(arr) {\n    var _ref;\n\n    return (_ref = []).concat.apply(_ref, toConsumableArray_default()(arr.map(function (val) {\n      return is_array_default()(val) ? flatten(val) : val;\n    })));\n  }\n\n  function cleanArray(arr) {\n    return arr.filter(function (elm) {\n      return typeof elm !== 'undefined';\n    });\n  } // =========================\n  // Is-Thing.\n  // =========================\n\n\n  function lib_isObject(val) {\n    return val && typeof_default()(val) === 'object';\n  }\n\n  function isPromise(val) {\n    return lib_isObject(val) && isFunction(val.then);\n  }\n\n  function isFunction(val) {\n    return val && typeof val === 'function';\n  }\n\n  function isError(patch) {\n    return patch instanceof Error;\n  }\n\n  function isJsonPatch(patch) {\n    if (isPatch(patch)) {\n      var op = patch.op;\n      return op === 'add' || op === 'remove' || op === 'replace';\n    }\n\n    return false;\n  }\n\n  function isGenerator(thing) {\n    return regenerator_default.a.isGeneratorFunction(thing);\n  }\n\n  function isMutation(patch) {\n    return isJsonPatch(patch) || isPatch(patch) && patch.type === 'mutation';\n  }\n\n  function isAdditiveMutation(patch) {\n    return isMutation(patch) && (patch.op === 'add' || patch.op === 'replace' || patch.op === 'merge' || patch.op === 'mergeDeep');\n  }\n\n  function isContextPatch(patch) {\n    return isPatch(patch) && patch.type === 'context';\n  }\n\n  function isPatch(patch) {\n    return patch && typeof_default()(patch) === 'object';\n  }\n\n  function getInByJsonPath(obj, jsonPath) {\n    try {\n      return external_fast_json_patch_default.a.getValueByPointer(obj, jsonPath);\n    } catch (e) {\n      console.error(e); // eslint-disable-line no-console\n\n      return {};\n    }\n  } // EXTERNAL MODULE: external \"@babel/runtime-corejs2/core-js/weak-map\"\n\n\n  var weak_map_ = __webpack_require__(35);\n\n  var weak_map_default =\n  /*#__PURE__*/\n  __webpack_require__.n(weak_map_); // EXTERNAL MODULE: external \"cross-fetch\"\n\n\n  var external_cross_fetch_ = __webpack_require__(36); // EXTERNAL MODULE: external \"querystring-browser\"\n\n\n  var external_querystring_browser_ = __webpack_require__(28);\n\n  var external_querystring_browser_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_querystring_browser_); // CONCATENATED MODULE: ./src/specmap/lib/create-error.js\n\n\n  function createErrorType(name, init) {\n    function E() {\n      if (!Error.captureStackTrace) {\n        this.stack = new Error().stack;\n      } else {\n        Error.captureStackTrace(this, this.constructor);\n      }\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      this.message = args[0];\n      init && init.apply(this, args);\n    }\n\n    E.prototype = new Error();\n    E.prototype.name = name;\n    E.prototype.constructor = E;\n    return E;\n  } // EXTERNAL MODULE: external \"traverse\"\n\n\n  var external_traverse_ = __webpack_require__(37);\n\n  var external_traverse_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_traverse_); // CONCATENATED MODULE: ./src/specmap/helpers.js\n  // This will match if the direct parent's key exactly matches an item.\n\n\n  var freelyNamedKeyParents = ['properties']; // This will match if the grandparent's key exactly matches an item.\n  // NOTE that this is for finding non-free paths!\n\n  var nonFreelyNamedKeyGrandparents = ['properties']; // This will match if the joined parent path exactly matches an item.\n  //\n  // This is mostly useful for filtering out root-level reusable item names,\n  // for example `[\"definitions\", \"$ref\"]`\n\n  var freelyNamedPaths = [// Swagger 2.0\n  'definitions', 'parameters', 'responses', 'securityDefinitions', // OpenAPI 3.0\n  'components/schemas', 'components/responses', 'components/parameters', 'components/securitySchemes']; // This will match if any of these items are substrings of the joined\n  // parent path.\n  //\n  // Warning! These are powerful. Beware of edge cases.\n\n  var freelyNamedAncestors = ['schema/example', 'items/example'];\n\n  function isFreelyNamed(parentPath) {\n    var parentKey = parentPath[parentPath.length - 1];\n    var grandparentKey = parentPath[parentPath.length - 2];\n    var parentStr = parentPath.join('/');\n    return (// eslint-disable-next-line max-len\n      freelyNamedKeyParents.indexOf(parentKey) > -1 && nonFreelyNamedKeyGrandparents.indexOf(grandparentKey) === -1 || freelyNamedPaths.indexOf(parentStr) > -1 || freelyNamedAncestors.some(function (el) {\n        return parentStr.indexOf(el) > -1;\n      })\n    );\n  }\n\n  function generateAbsoluteRefPatches(obj, basePath) {\n    var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        specmap = _ref.specmap,\n        _ref$getBaseUrlForNod = _ref.getBaseUrlForNodePath,\n        getBaseUrlForNodePath = _ref$getBaseUrlForNod === void 0 ? function (path) {\n      return specmap.getContext([].concat(toConsumableArray_default()(basePath), toConsumableArray_default()(path))).baseDoc;\n    } : _ref$getBaseUrlForNod,\n        _ref$targetKeys = _ref.targetKeys,\n        targetKeys = _ref$targetKeys === void 0 ? ['$ref', '$$ref'] : _ref$targetKeys;\n\n    var patches = [];\n    external_traverse_default()(obj).forEach(function () {\n      if (targetKeys.indexOf(this.key) > -1) {\n        var nodePath = this.path; // this node's path, relative to `obj`\n\n        var fullPath = basePath.concat(this.path);\n        var absolutifiedRefValue = absolutifyPointer(this.node, getBaseUrlForNodePath(nodePath));\n        patches.push(specmap.replace(fullPath, absolutifiedRefValue));\n      }\n    });\n    return patches;\n  }\n\n  function absolutifyPointer(pointer, baseUrl) {\n    var _pointer$split = pointer.split('#'),\n        _pointer$split2 = slicedToArray_default()(_pointer$split, 2),\n        urlPart = _pointer$split2[0],\n        fragmentPart = _pointer$split2[1];\n\n    var newRefUrlPart = external_url_default.a.resolve(urlPart || '', baseUrl || '');\n    return fragmentPart ? \"\".concat(newRefUrlPart, \"#\").concat(fragmentPart) : newRefUrlPart;\n  } // CONCATENATED MODULE: ./src/constants.js\n\n\n  var ACCEPT_HEADER_VALUE_FOR_DOCUMENTS = 'application/json, application/yaml'; // CONCATENATED MODULE: ./src/specmap/lib/refs.js\n\n  var ABSOLUTE_URL_REGEXP = new RegExp('^([a-z]+://|//)', 'i');\n  var JSONRefError = createErrorType('JSONRefError', function (message, extra, oriError) {\n    this.originalError = oriError;\n    object_assign_default()(this, extra || {});\n  });\n  var docCache = {};\n  var specmapRefs = new weak_map_default.a();\n  var skipResolutionTestFns = [function (path) {\n    return (// OpenAPI 3.0 Response Media Type Example\n      // [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\n      path[0] === 'paths' && path[3] === 'responses' && path[5] === 'content' && path[7] === 'example'\n    );\n  }, function (path) {\n    return (// OpenAPI 3.0 Request Body Media Type Example\n      // [\"paths\", *, *, \"responses\", *, \"content\", *, \"example\"]\n      path[0] === 'paths' && path[3] === 'requestBody' && path[4] === 'content' && path[6] === 'example'\n    );\n  }];\n\n  var shouldSkipResolution = function shouldSkipResolution(path) {\n    return skipResolutionTestFns.some(function (fn) {\n      return fn(path);\n    });\n  }; // =========================\n  // Core\n  // =========================\n\n  /**\n   * This plugin resolves the JSON pointers.\n   * A major part of this plugin deals with cyclic references via 2 mechanisms.\n   * 1. If a pointer was already resolved before in this path, halt.\n   * 2. If the patch value points to one of the ancestors in this path, halt.\n   *\n   * Note that either one of these mechanism is sufficient, both must be in place.\n   * For examples:\n   *\n   * Given the following spec, #1 alone is insufficient because after the 2nd\n   * application, there will be a cyclic object reference.\n   *   a.b.c: $ref-d\n   *   d.e.f: $ref-a (per #1, safe to return patch as no immediate cycle)\n   *\n   * Given the following spec, #2 alone is insufficient because although there will\n   * never be any cyclic object reference, the plugin will keep producing patches.\n   *   a: $ref-b\n   *   b: $ref-a\n   */\n\n\n  var refs_plugin = {\n    key: '$ref',\n    plugin: function plugin(ref, key, fullPath, specmap) {\n      var specmapInstance = specmap.getInstance();\n      var parent = fullPath.slice(0, -1);\n\n      if (isFreelyNamed(parent) || shouldSkipResolution(parent)) {\n        return;\n      }\n\n      var baseDoc = specmap.getContext(fullPath).baseDoc;\n\n      if (typeof ref !== 'string') {\n        return new JSONRefError('$ref: must be a string (JSON-Ref)', {\n          $ref: ref,\n          baseDoc: baseDoc,\n          fullPath: fullPath\n        });\n      }\n\n      var splitString = split(ref);\n      var refPath = splitString[0];\n      var pointer = splitString[1] || '';\n      var basePath;\n\n      try {\n        basePath = baseDoc || refPath ? absoluteify(refPath, baseDoc) : null;\n      } catch (e) {\n        return wrapError(e, {\n          pointer: pointer,\n          $ref: ref,\n          basePath: basePath,\n          fullPath: fullPath\n        });\n      }\n\n      var promOrVal;\n      var tokens;\n\n      if (pointerAlreadyInPath(pointer, basePath, parent, specmap)) {\n        // Cyclic reference!\n        // if `useCircularStructures` is not set, just leave the reference\n        // unresolved, but absolutify it so that we don't leave an invalid $ref\n        // path in the content\n        if (!specmapInstance.useCircularStructures) {\n          var _absolutifiedRef = absolutifyPointer(ref, basePath);\n\n          if (ref === _absolutifiedRef) {\n            // avoids endless looping\n            // without this, the ref plugin never stops seeing this $ref\n            return null;\n          }\n\n          return lib.replace(fullPath, _absolutifiedRef);\n        }\n      }\n\n      if (basePath == null) {\n        tokens = jsonPointerToArray(pointer);\n        promOrVal = specmap.get(tokens);\n\n        if (typeof promOrVal === 'undefined') {\n          promOrVal = new JSONRefError(\"Could not resolve reference: \".concat(ref), {\n            pointer: pointer,\n            $ref: ref,\n            baseDoc: baseDoc,\n            fullPath: fullPath\n          });\n        }\n      } else {\n        promOrVal = extractFromDoc(basePath, pointer);\n\n        if (promOrVal.__value != null) {\n          promOrVal = promOrVal.__value;\n        } else {\n          promOrVal = promOrVal.catch(function (e) {\n            throw wrapError(e, {\n              pointer: pointer,\n              $ref: ref,\n              baseDoc: baseDoc,\n              fullPath: fullPath\n            });\n          });\n        }\n      }\n\n      if (promOrVal instanceof Error) {\n        return [lib.remove(fullPath), promOrVal];\n      }\n\n      var absolutifiedRef = absolutifyPointer(ref, basePath);\n      var patch = lib.replace(parent, promOrVal, {\n        $$ref: absolutifiedRef\n      });\n\n      if (basePath && basePath !== baseDoc) {\n        return [patch, lib.context(parent, {\n          baseDoc: basePath\n        })];\n      }\n\n      try {\n        // prevents circular values from being constructed, unless we specifically\n        // want that to happen\n        if (!patchValueAlreadyInPath(specmap.state, patch) || specmapInstance.useCircularStructures) {\n          return patch;\n        }\n      } catch (e) {\n        // if we're catching here, path traversal failed, so we should\n        // ditch without sending any patches back up.\n        //\n        // this is a narrow fix for the larger problem of patches being queued\n        // and then having the state they were generated against be modified\n        // before they are applied.\n        //\n        // TODO: re-engineer specmap patch/state management to avoid this\n        return null;\n      }\n    }\n  };\n  var mod = object_assign_default()(refs_plugin, {\n    docCache: docCache,\n    absoluteify: absoluteify,\n    clearCache: clearCache,\n    JSONRefError: JSONRefError,\n    wrapError: wrapError,\n    getDoc: getDoc,\n    split: split,\n    extractFromDoc: extractFromDoc,\n    fetchJSON: fetchJSON,\n    extract: extract,\n    jsonPointerToArray: jsonPointerToArray,\n    unescapeJsonPointerToken: unescapeJsonPointerToken\n  });\n  /* harmony default export */\n\n  var refs = mod; // =========================\n  // Utilities\n  // =========================\n\n  /**\n   * Resolves a path and its base to an abolute URL.\n   * @api public\n   */\n\n  function absoluteify(path, basePath) {\n    if (!ABSOLUTE_URL_REGEXP.test(path)) {\n      if (!basePath) {\n        throw new JSONRefError(\"Tried to resolve a relative URL, without having a basePath. path: '\".concat(path, \"' basePath: '\").concat(basePath, \"'\"));\n      }\n\n      return external_url_default.a.resolve(basePath, path);\n    }\n\n    return path;\n  }\n  /**\n     * Wraps an error as JSONRefError.\n     * @param  {Error} e      the error.\n     * @param  {Object} extra (optional) optional data.\n     * @return {Error}        an instance of JSONRefError.\n     * @api public\n     */\n\n\n  function wrapError(e, extra) {\n    var message;\n\n    if (e && e.response && e.response.body) {\n      message = \"\".concat(e.response.body.code, \" \").concat(e.response.body.message);\n    } else {\n      message = e.message;\n    }\n\n    return new JSONRefError(\"Could not resolve reference: \".concat(message), extra, e);\n  }\n  /**\n     * Splits a pointer by the hash delimiter.\n     * @api public\n     */\n\n\n  function split(ref) {\n    return (ref + '').split('#'); // eslint-disable-line prefer-template\n  }\n  /**\n     * Extracts a pointer from its document.\n     * @param  {String} docPath the absolute document URL.\n     * @param  {String} pointer the pointer whose value is to be extracted.\n     * @return {Promise}        a promise of the pointer value.\n     * @api public\n     */\n\n\n  function extractFromDoc(docPath, pointer) {\n    var doc = docCache[docPath];\n\n    if (doc && !lib.isPromise(doc)) {\n      // If doc is already available, return __value together with the promise.\n      // __value is for special handling in cycle check:\n      // pointerAlreadyInPath() won't work if patch.value is a promise,\n      // thus when that promise is finally resolved, cycle might happen (because\n      // `spec` and `docCache[basePath]` refer to the exact same object).\n      // See test \"should resolve a cyclic spec when baseDoc is specified\".\n      try {\n        var v = extract(pointer, doc);\n        return object_assign_default()(promise_default.a.resolve(v), {\n          __value: v\n        });\n      } catch (e) {\n        return promise_default.a.reject(e);\n      }\n    }\n\n    return getDoc(docPath).then(function (_doc) {\n      return extract(pointer, _doc);\n    });\n  }\n  /**\n     * Clears all document caches.\n     * @param  {String} item (optional) the name of the cache item to be cleared.\n     * @api public\n     */\n\n\n  function clearCache(item) {\n    if (typeof item !== 'undefined') {\n      delete docCache[item];\n    } else {\n      keys_default()(docCache).forEach(function (key) {\n        delete docCache[key];\n      });\n    }\n  }\n  /**\n     * Fetches and caches a document.\n     * @param  {String} docPath the absolute URL of the document.\n     * @return {Promise}        a promise of the document content.\n     * @api public\n     */\n\n\n  function getDoc(docPath) {\n    var val = docCache[docPath];\n\n    if (val) {\n      return lib.isPromise(val) ? val : promise_default.a.resolve(val);\n    } // NOTE: we need to use `mod.fetchJSON` in order to be able to overwrite it.\n    // Any tips on how to make this cleaner, please ping!\n\n\n    docCache[docPath] = mod.fetchJSON(docPath).then(function (doc) {\n      docCache[docPath] = doc;\n      return doc;\n    });\n    return docCache[docPath];\n  }\n  /**\n     * Fetches a document.\n     * @param  {String} docPath the absolute URL of the document.\n     * @return {Promise}        a promise of the document content.\n     * @api public\n     */\n\n\n  function fetchJSON(docPath) {\n    return Object(external_cross_fetch_[\"fetch\"])(docPath, {\n      headers: {\n        Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n      },\n      loadSpec: true\n    }).then(function (res) {\n      return res.text();\n    }).then(function (text) {\n      return external_js_yaml_default.a.safeLoad(text);\n    });\n  }\n  /**\n     * Extracts a pointer from an object.\n     * @param  {String[]} pointer the JSON pointer.\n     * @param  {Object} obj       an object whose value is to be extracted.\n     * @return {Object}           the value to be extracted.\n     * @api public\n     */\n\n\n  function extract(pointer, obj) {\n    var tokens = jsonPointerToArray(pointer);\n\n    if (tokens.length < 1) {\n      return obj;\n    }\n\n    var val = lib.getIn(obj, tokens);\n\n    if (typeof val === 'undefined') {\n      throw new JSONRefError(\"Could not resolve pointer: \".concat(pointer, \" does not exist in document\"), {\n        pointer: pointer\n      });\n    }\n\n    return val;\n  }\n  /**\n     * Converts a JSON pointer to array.\n     * @api public\n     */\n\n\n  function jsonPointerToArray(pointer) {\n    if (typeof pointer !== 'string') {\n      throw new TypeError(\"Expected a string, got a \".concat(typeof_default()(pointer)));\n    }\n\n    if (pointer[0] === '/') {\n      pointer = pointer.substr(1);\n    }\n\n    if (pointer === '') {\n      return [];\n    }\n\n    return pointer.split('/').map(unescapeJsonPointerToken);\n  }\n  /**\n     * Unescapes a JSON pointer.\n     * @api public\n     */\n\n\n  function unescapeJsonPointerToken(token) {\n    if (typeof token !== 'string') {\n      return token;\n    }\n\n    return external_querystring_browser_default.a.unescape(token.replace(/~1/g, '/').replace(/~0/g, '~'));\n  }\n  /**\n     * Escapes a JSON pointer.\n     * @api public\n     */\n\n\n  function escapeJsonPointerToken(token) {\n    return external_querystring_browser_default.a.escape(token.replace(/~/g, '~0').replace(/\\//g, '~1'));\n  }\n\n  function arrayToJsonPointer(arr) {\n    if (arr.length === 0) {\n      return '';\n    }\n\n    return \"/\".concat(arr.map(escapeJsonPointerToken).join('/'));\n  }\n\n  var pointerBoundaryChar = function pointerBoundaryChar(c) {\n    return !c || c === '/' || c === '#';\n  };\n\n  function pointerIsAParent(pointer, parentPointer) {\n    if (pointerBoundaryChar(parentPointer)) {\n      // This is the root of the document, so its naturally a parent\n      return true;\n    }\n\n    var nextChar = pointer.charAt(parentPointer.length);\n    var lastParentChar = parentPointer.slice(-1);\n    return pointer.indexOf(parentPointer) === 0 && (!nextChar || nextChar === '/' || nextChar === '#') && lastParentChar !== '#';\n  } // =========================\n  // Private\n  // =========================\n\n  /**\n   * Checks if this pointer points back to one or more pointers along the path.\n   */\n\n\n  function pointerAlreadyInPath(pointer, basePath, parent, specmap) {\n    var refs = specmapRefs.get(specmap);\n\n    if (!refs) {\n      // Stores all resolved references of a specmap instance.\n      // Schema: path -> pointer (path's $ref value).\n      refs = {};\n      specmapRefs.set(specmap, refs);\n    }\n\n    var parentPointer = arrayToJsonPointer(parent);\n    var fullyQualifiedPointer = \"\".concat(basePath || '<specmap-base>', \"#\").concat(pointer); // dirty hack to strip `allof/[index]` from the path, in order to avoid cases\n    // where we get false negatives because:\n    // - we resolve a path, then\n    // - allOf plugin collapsed `allOf/[index]` out of the path, then\n    // - we try to work on a child $ref within that collapsed path.\n    //\n    // because of the path collapse, we lose track of it in our specmapRefs hash\n    // solution: always throw the allOf constructs out of paths we store\n    // TODO: solve this with a global register, or by writing more metadata in\n    // either allOf or refs plugin\n\n    var safeParentPointer = parentPointer.replace(/allOf\\/\\d+\\/?/g, ''); // Case 1: direct cycle, e.g. a.b.c.$ref: '/a.b'\n    // Detect by checking that the parent path doesn't start with pointer.\n    // This only applies if the pointer is internal, i.e. basePath === rootPath (could be null)\n\n    var rootDoc = specmap.contextTree.get([]).baseDoc;\n\n    if (basePath == rootDoc && pointerIsAParent(safeParentPointer, pointer)) {\n      // eslint-disable-line\n      return true;\n    } // Case 2: indirect cycle\n    //  ex1: a.$ref: '/b'  &  b.c.$ref: '/b/c'\n    //  ex2: a.$ref: '/b/c'  &  b.c.$ref: '/b'\n    // Detect by retrieving all the $refs along the path of parent\n    // and checking if any starts with pointer or vice versa.\n\n\n    var currPath = '';\n    var hasIndirectCycle = parent.some(function (token) {\n      currPath = \"\".concat(currPath, \"/\").concat(escapeJsonPointerToken(token));\n      return refs[currPath] && refs[currPath].some(function (ref) {\n        return pointerIsAParent(ref, fullyQualifiedPointer) || pointerIsAParent(fullyQualifiedPointer, ref);\n      });\n    });\n\n    if (hasIndirectCycle) {\n      return true;\n    } // No cycle, this ref will be resolved, so stores it now for future detection.\n    // No need to store if has cycle, as parent path is a dead-end and won't be checked again.\n\n\n    refs[safeParentPointer] = (refs[safeParentPointer] || []).concat(fullyQualifiedPointer);\n  }\n  /**\n     * Checks if the value of this patch ends up pointing to an ancestor along the path.\n     */\n\n\n  function patchValueAlreadyInPath(root, patch) {\n    var ancestors = [root];\n    patch.path.reduce(function (parent, p) {\n      ancestors.push(parent[p]);\n      return parent[p];\n    }, root);\n    return pointToAncestor(patch.value);\n\n    function pointToAncestor(obj) {\n      return lib.isObject(obj) && (ancestors.indexOf(obj) >= 0 || keys_default()(obj).some(function (k) {\n        return pointToAncestor(obj[k]);\n      }));\n    }\n  } // CONCATENATED MODULE: ./src/specmap/lib/all-of.js\n\n  /* harmony default export */\n\n\n  var all_of = {\n    key: 'allOf',\n    plugin: function plugin(val, key, fullPath, specmap, patch) {\n      // Ignore replace patches created by $ref because the changes will\n      // occur in the original \"add\" patch and we don't want this plugin\n      // to redundantly processes those \"relace\" patches.\n      if (patch.meta && patch.meta.$$ref) {\n        return;\n      }\n\n      var parent = fullPath.slice(0, -1);\n\n      if (isFreelyNamed(parent)) {\n        return;\n      }\n\n      if (!is_array_default()(val)) {\n        var err = new TypeError('allOf must be an array');\n        err.fullPath = fullPath; // This is an array\n\n        return err;\n      }\n\n      var alreadyAddError = false; // Find the original definition from the `patch.value` object\n      // Remove the `allOf` property so it doesn't get added to the result of the `allOf` plugin\n\n      var originalDefinitionObj = patch.value;\n      parent.forEach(function (part) {\n        if (!originalDefinitionObj) return; // bail out if we've lost sight of our target\n\n        originalDefinitionObj = originalDefinitionObj[part];\n      });\n      originalDefinitionObj = object_assign_default()({}, originalDefinitionObj);\n      delete originalDefinitionObj.allOf;\n      var patches = []; // remove existing content\n\n      patches.push(specmap.replace(parent, {}));\n      val.forEach(function (toMerge, i) {\n        if (!specmap.isObject(toMerge)) {\n          if (alreadyAddError) {\n            return null;\n          }\n\n          alreadyAddError = true;\n\n          var _err = new TypeError('Elements in allOf must be objects');\n\n          _err.fullPath = fullPath; // This is an array\n\n          return patches.push(_err);\n        } // Deeply merge the member's contents onto the parent location\n\n\n        patches.push(specmap.mergeDeep(parent, toMerge)); // Generate patches that migrate $ref values based on ContextTree information\n        // remove [\"allOf\"], which will not be present when these patches are applied\n\n        var collapsedFullPath = fullPath.slice(0, -1);\n        var absoluteRefPatches = generateAbsoluteRefPatches(toMerge, collapsedFullPath, {\n          getBaseUrlForNodePath: function getBaseUrlForNodePath(nodePath) {\n            return specmap.getContext([].concat(toConsumableArray_default()(fullPath), [i], toConsumableArray_default()(nodePath))).baseDoc;\n          },\n          specmap: specmap\n        });\n        patches.push.apply(patches, toConsumableArray_default()(absoluteRefPatches));\n      }); // Merge back the values from the original definition\n\n      patches.push(specmap.mergeDeep(parent, originalDefinitionObj)); // If there was not an original $$ref value, make sure to remove\n      // any $$ref value that may exist from the result of `allOf` merges\n\n      if (!originalDefinitionObj.$$ref) {\n        patches.push(specmap.remove([].concat(parent, '$$ref')));\n      }\n\n      return patches;\n    }\n  }; // CONCATENATED MODULE: ./src/specmap/lib/parameters.js\n\n  /* harmony default export */\n\n  var lib_parameters = {\n    key: 'parameters',\n    plugin: function plugin(parameters, key, fullPath, specmap, patch) {\n      if (is_array_default()(parameters) && parameters.length) {\n        var val = object_assign_default()([], parameters);\n        var opPath = fullPath.slice(0, -1);\n        var op = object_assign_default()({}, lib.getIn(specmap.spec, opPath));\n        parameters.forEach(function (param, i) {\n          try {\n            val[i].default = specmap.parameterMacro(op, param);\n          } catch (e) {\n            var err = new Error(e);\n            err.fullPath = fullPath;\n            return err;\n          }\n        });\n        return lib.replace(fullPath, val);\n      }\n\n      return lib.replace(fullPath, parameters);\n    }\n  }; // CONCATENATED MODULE: ./src/specmap/lib/properties.js\n\n  /* harmony default export */\n\n  var lib_properties = {\n    key: 'properties',\n    plugin: function plugin(properties, key, fullPath, specmap) {\n      var val = object_assign_default()({}, properties);\n\n      for (var k in properties) {\n        try {\n          val[k].default = specmap.modelPropertyMacro(val[k]);\n        } catch (e) {\n          var err = new Error(e);\n          err.fullPath = fullPath; // This is an array\n\n          return err;\n        }\n      }\n\n      var patch = lib.replace(fullPath, val);\n      return patch;\n    }\n  }; // CONCATENATED MODULE: ./src/specmap/lib/context-tree.js\n\n  function ownKeys(object, enumerableOnly) {\n    var keys = keys_default()(object);\n\n    if (get_own_property_symbols_default.a) {\n      var symbols = get_own_property_symbols_default()(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return get_own_property_descriptor_default()(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function _objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        ownKeys(source, true).forEach(function (key) {\n          defineProperty_default()(target, key, source[key]);\n        });\n      } else if (get_own_property_descriptors_default.a) {\n        define_properties_default()(target, get_own_property_descriptors_default()(source));\n      } else {\n        ownKeys(source).forEach(function (key) {\n          define_property_default()(target, key, get_own_property_descriptor_default()(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  var context_tree_ContextTree =\n  /*#__PURE__*/\n  function () {\n    function ContextTree(value) {\n      classCallCheck_default()(this, ContextTree);\n      this.root = createNode(value || {});\n    }\n\n    createClass_default()(ContextTree, [{\n      key: \"set\",\n      value: function set(path, value) {\n        var parent = this.getParent(path, true);\n\n        if (!parent) {\n          updateNode(this.root, value, null);\n          return;\n        }\n\n        var key = path[path.length - 1];\n        var children = parent.children;\n\n        if (children[key]) {\n          updateNode(children[key], value, parent);\n          return;\n        }\n\n        children[key] = createNode(value, parent);\n      } // Get the \"best\" node (node or nearest parent) and return its value.\n\n    }, {\n      key: \"get\",\n      value: function get(path) {\n        path = path || [];\n\n        if (path.length < 1) {\n          return this.root.value;\n        }\n\n        var branch = this.root;\n        var child;\n        var token;\n\n        for (var i = 0; i < path.length; i++) {\n          token = path[i];\n          child = branch.children;\n\n          if (!child[token]) {\n            break;\n          }\n\n          branch = child[token];\n        }\n\n        return branch && branch.protoValue;\n      }\n    }, {\n      key: \"getParent\",\n      value: function getParent(path, ensureExists) {\n        if (!path || path.length < 1) {\n          return null;\n        }\n\n        if (path.length < 2) {\n          return this.root;\n        }\n\n        return path.slice(0, -1).reduce(function (branch, token) {\n          if (!branch) {\n            return branch;\n          }\n\n          var children = branch.children;\n\n          if (!children[token] && ensureExists) {\n            children[token] = createNode(null, branch);\n          }\n\n          return children[token];\n        }, this.root);\n      }\n    }]);\n    return ContextTree;\n  }(); // =========================\n  // Utilities\n  // =========================\n\n\n  function createNode(value, parent) {\n    return updateNode({\n      children: {}\n    }, value, parent);\n  }\n\n  function updateNode(node, value, parent) {\n    node.value = value || {};\n    node.protoValue = parent ? _objectSpread({}, parent.protoValue, {}, node.value) : node.value;\n    keys_default()(node.children).forEach(function (prop) {\n      var child = node.children[prop];\n      node.children[prop] = updateNode(child, child.value, node);\n    });\n    return node;\n  } // CONCATENATED MODULE: ./src/specmap/index.js\n\n\n  var HARD_LIMIT = 100;\n\n  var specmap_SpecMap =\n  /*#__PURE__*/\n  function () {\n    function SpecMap(opts) {\n      var _this = this;\n\n      classCallCheck_default()(this, SpecMap);\n      object_assign_default()(this, {\n        spec: '',\n        debugLevel: 'info',\n        plugins: [],\n        pluginHistory: {},\n        errors: [],\n        mutations: [],\n        promisedPatches: [],\n        state: {},\n        patches: [],\n        context: {},\n        contextTree: new context_tree_ContextTree(),\n        showDebug: false,\n        allPatches: [],\n        // only populated if showDebug is true\n        pluginProp: 'specMap',\n        libMethods: object_assign_default()(create_default()(this), lib, {\n          getInstance: function getInstance() {\n            return _this;\n          }\n        }),\n        allowMetaPatches: false\n      }, opts); // Lib methods bound\n\n      this.get = this._get.bind(this);\n      this.getContext = this._getContext.bind(this);\n      this.hasRun = this._hasRun.bind(this);\n      this.wrappedPlugins = this.plugins.map(this.wrapPlugin.bind(this)).filter(lib.isFunction); // Initial patch(s)\n\n      this.patches.push(lib.add([], this.spec));\n      this.patches.push(lib.context([], this.context));\n      this.updatePatches(this.patches);\n    }\n\n    createClass_default()(SpecMap, [{\n      key: \"debug\",\n      value: function debug(level) {\n        if (this.debugLevel === level) {\n          var _console;\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          (_console = console).log.apply(_console, args); // eslint-disable-line no-console\n\n        }\n      }\n    }, {\n      key: \"verbose\",\n      value: function verbose(header) {\n        if (this.debugLevel === 'verbose') {\n          var _console2;\n\n          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n            args[_key2 - 1] = arguments[_key2];\n          }\n\n          (_console2 = console).log.apply(_console2, [\"[\".concat(header, \"]   \")].concat(args)); // eslint-disable-line no-console\n\n        }\n      }\n    }, {\n      key: \"wrapPlugin\",\n      value: function wrapPlugin(plugin, name) {\n        var pathDiscriminator = this.pathDiscriminator;\n        var ctx = null;\n        var fn;\n\n        if (plugin[this.pluginProp]) {\n          ctx = plugin;\n          fn = plugin[this.pluginProp];\n        } else if (lib.isFunction(plugin)) {\n          fn = plugin;\n        } else if (lib.isObject(plugin)) {\n          fn = createKeyBasedPlugin(plugin);\n        }\n\n        return object_assign_default()(fn.bind(ctx), {\n          pluginName: plugin.name || name,\n          isGenerator: lib.isGenerator(fn)\n        }); // Expected plugin interface: {key: string, plugin: fn*}\n        // This traverses depth-first and immediately applies yielded patches.\n        // This strategy should work well for most plugins (including the built-ins).\n        // We might consider making this (traversing & application) configurable later.\n\n        function createKeyBasedPlugin(pluginObj) {\n          var isSubPath = function isSubPath(path, tested) {\n            if (!is_array_default()(path)) {\n              return true;\n            }\n\n            return path.every(function (val, i) {\n              return val === tested[i];\n            });\n          };\n\n          return (\n            /*#__PURE__*/\n            regenerator_default.a.mark(function _callee(patches, specmap) {\n              var _marked, refCache, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, patch, traverse;\n\n              return regenerator_default.a.wrap(function _callee$(_context2) {\n                while (1) {\n                  switch (_context2.prev = _context2.next) {\n                    case 0:\n                      traverse = function _ref(obj, path, patch) {\n                        var parentIndex, parent, indexOfFirstProperties, isRootProperties, traversed, _i, _Object$keys, key, val, updatedPath, isObj, objRef, isWithinPathDiscriminator;\n\n                        return regenerator_default.a.wrap(function traverse$(_context) {\n                          while (1) {\n                            switch (_context.prev = _context.next) {\n                              case 0:\n                                if (lib.isObject(obj)) {\n                                  _context.next = 6;\n                                  break;\n                                }\n\n                                if (!(pluginObj.key === path[path.length - 1])) {\n                                  _context.next = 4;\n                                  break;\n                                }\n\n                                _context.next = 4;\n                                return pluginObj.plugin(obj, pluginObj.key, path, specmap);\n\n                              case 4:\n                                _context.next = 30;\n                                break;\n\n                              case 6:\n                                parentIndex = path.length - 1;\n                                parent = path[parentIndex];\n                                indexOfFirstProperties = path.indexOf('properties');\n                                isRootProperties = parent === 'properties' && parentIndex === indexOfFirstProperties;\n                                traversed = specmap.allowMetaPatches && refCache[obj.$$ref];\n                                _i = 0, _Object$keys = keys_default()(obj);\n\n                              case 12:\n                                if (!(_i < _Object$keys.length)) {\n                                  _context.next = 30;\n                                  break;\n                                }\n\n                                key = _Object$keys[_i];\n                                val = obj[key];\n                                updatedPath = path.concat(key);\n                                isObj = lib.isObject(val);\n                                objRef = obj.$$ref;\n\n                                if (traversed) {\n                                  _context.next = 22;\n                                  break;\n                                }\n\n                                if (!isObj) {\n                                  _context.next = 22;\n                                  break;\n                                } // Only store the ref if it exists\n\n\n                                if (specmap.allowMetaPatches && objRef) {\n                                  refCache[objRef] = true;\n                                }\n\n                                return _context.delegateYield(traverse(val, updatedPath, patch), \"t0\", 22);\n\n                              case 22:\n                                if (!(!isRootProperties && key === pluginObj.key)) {\n                                  _context.next = 27;\n                                  break;\n                                }\n\n                                isWithinPathDiscriminator = isSubPath(pathDiscriminator, path);\n\n                                if (!(!pathDiscriminator || isWithinPathDiscriminator)) {\n                                  _context.next = 27;\n                                  break;\n                                }\n\n                                _context.next = 27;\n                                return pluginObj.plugin(val, key, updatedPath, specmap, patch);\n\n                              case 27:\n                                _i++;\n                                _context.next = 12;\n                                break;\n\n                              case 30:\n                              case \"end\":\n                                return _context.stop();\n                            }\n                          }\n                        }, _marked);\n                      };\n\n                      _marked =\n                      /*#__PURE__*/\n                      regenerator_default.a.mark(traverse);\n                      refCache = {};\n                      _iteratorNormalCompletion = true;\n                      _didIteratorError = false;\n                      _iteratorError = undefined;\n                      _context2.prev = 6;\n                      _iterator = get_iterator_default()(patches.filter(lib.isAdditiveMutation));\n\n                    case 8:\n                      if (_iteratorNormalCompletion = (_step = _iterator.next()).done) {\n                        _context2.next = 14;\n                        break;\n                      }\n\n                      patch = _step.value;\n                      return _context2.delegateYield(traverse(patch.value, patch.path, patch), \"t0\", 11);\n\n                    case 11:\n                      _iteratorNormalCompletion = true;\n                      _context2.next = 8;\n                      break;\n\n                    case 14:\n                      _context2.next = 20;\n                      break;\n\n                    case 16:\n                      _context2.prev = 16;\n                      _context2.t1 = _context2[\"catch\"](6);\n                      _didIteratorError = true;\n                      _iteratorError = _context2.t1;\n\n                    case 20:\n                      _context2.prev = 20;\n                      _context2.prev = 21;\n\n                      if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                      }\n\n                    case 23:\n                      _context2.prev = 23;\n\n                      if (!_didIteratorError) {\n                        _context2.next = 26;\n                        break;\n                      }\n\n                      throw _iteratorError;\n\n                    case 26:\n                      return _context2.finish(23);\n\n                    case 27:\n                      return _context2.finish(20);\n\n                    case 28:\n                    case \"end\":\n                      return _context2.stop();\n                  }\n                }\n              }, _callee, null, [[6, 16, 20, 28], [21,, 23, 27]]);\n            })\n          );\n        }\n      }\n    }, {\n      key: \"nextPlugin\",\n      value: function nextPlugin() {\n        var _this2 = this; // Array.prototype.find doesn't work in IE 11 :(\n\n\n        return find_default()(this.wrappedPlugins, function (plugin) {\n          var mutations = _this2.getMutationsForPlugin(plugin);\n\n          return mutations.length > 0;\n        });\n      }\n    }, {\n      key: \"nextPromisedPatch\",\n      value: function nextPromisedPatch() {\n        if (this.promisedPatches.length > 0) {\n          return promise_default.a.race(this.promisedPatches.map(function (patch) {\n            return patch.value;\n          }));\n        }\n      }\n    }, {\n      key: \"getPluginHistory\",\n      value: function getPluginHistory(plugin) {\n        var name = this.getPluginName(plugin);\n        return this.pluginHistory[name] || [];\n      }\n    }, {\n      key: \"getPluginRunCount\",\n      value: function getPluginRunCount(plugin) {\n        return this.getPluginHistory(plugin).length;\n      }\n    }, {\n      key: \"getPluginHistoryTip\",\n      value: function getPluginHistoryTip(plugin) {\n        var history = this.getPluginHistory(plugin);\n        var val = history && history[history.length - 1];\n        return val || {};\n      }\n    }, {\n      key: \"getPluginMutationIndex\",\n      value: function getPluginMutationIndex(plugin) {\n        var mi = this.getPluginHistoryTip(plugin).mutationIndex;\n        return typeof mi !== 'number' ? -1 : mi;\n      }\n    }, {\n      key: \"getPluginName\",\n      value: function getPluginName(plugin) {\n        return plugin.pluginName;\n      }\n    }, {\n      key: \"updatePluginHistory\",\n      value: function updatePluginHistory(plugin, val) {\n        var name = this.getPluginName(plugin);\n        var history = this.pluginHistory[name] = this.pluginHistory[name] || [];\n        history.push(val);\n      }\n    }, {\n      key: \"updatePatches\",\n      value: function updatePatches(patches, plugin) {\n        var _this3 = this;\n\n        lib.normalizeArray(patches).forEach(function (patch) {\n          if (patch instanceof Error) {\n            _this3.errors.push(patch);\n\n            return;\n          }\n\n          try {\n            if (!lib.isObject(patch)) {\n              _this3.debug('updatePatches', 'Got a non-object patch', patch);\n\n              return;\n            }\n\n            if (_this3.showDebug) {\n              _this3.allPatches.push(patch);\n            }\n\n            if (lib.isPromise(patch.value)) {\n              _this3.promisedPatches.push(patch);\n\n              _this3.promisedPatchThen(patch);\n\n              return;\n            }\n\n            if (lib.isContextPatch(patch)) {\n              _this3.setContext(patch.path, patch.value);\n\n              return;\n            }\n\n            if (lib.isMutation(patch)) {\n              _this3.updateMutations(patch);\n\n              return;\n            }\n          } catch (e) {\n            console.error(e); // eslint-disable-line no-console\n\n            _this3.errors.push(e);\n          }\n        });\n      }\n    }, {\n      key: \"updateMutations\",\n      value: function updateMutations(patch) {\n        if (typeof_default()(patch.value) === 'object' && !is_array_default()(patch.value) && this.allowMetaPatches) {\n          patch.value = object_assign_default()({}, patch.value);\n        }\n\n        var result = lib.applyPatch(this.state, patch, {\n          allowMetaPatches: this.allowMetaPatches\n        });\n\n        if (result) {\n          this.mutations.push(patch);\n          this.state = result;\n        }\n      }\n    }, {\n      key: \"removePromisedPatch\",\n      value: function removePromisedPatch(patch) {\n        var index = this.promisedPatches.indexOf(patch);\n\n        if (index < 0) {\n          this.debug('Tried to remove a promisedPatch that isn\\'t there!');\n          return;\n        }\n\n        this.promisedPatches.splice(index, 1);\n      }\n    }, {\n      key: \"promisedPatchThen\",\n      value: function promisedPatchThen(patch) {\n        var _this4 = this;\n\n        var value = patch.value = patch.value.then(function (val) {\n          var promisedPatch = object_assign_default()({}, patch, {\n            value: val\n          });\n\n          _this4.removePromisedPatch(patch);\n\n          _this4.updatePatches(promisedPatch);\n        }).catch(function (e) {\n          _this4.removePromisedPatch(patch);\n\n          _this4.updatePatches(e);\n        });\n        return value;\n      }\n    }, {\n      key: \"getMutations\",\n      value: function getMutations(from, to) {\n        from = from || 0;\n\n        if (typeof to !== 'number') {\n          to = this.mutations.length;\n        }\n\n        return this.mutations.slice(from, to);\n      }\n    }, {\n      key: \"getCurrentMutations\",\n      value: function getCurrentMutations() {\n        return this.getMutationsForPlugin(this.getCurrentPlugin());\n      }\n    }, {\n      key: \"getMutationsForPlugin\",\n      value: function getMutationsForPlugin(plugin) {\n        var tip = this.getPluginMutationIndex(plugin);\n        return this.getMutations(tip + 1);\n      }\n    }, {\n      key: \"getCurrentPlugin\",\n      value: function getCurrentPlugin() {\n        return this.currentPlugin;\n      }\n    }, {\n      key: \"getPatchesOfType\",\n      value: function getPatchesOfType(patches, fn) {\n        return patches.filter(fn);\n      }\n    }, {\n      key: \"getLib\",\n      value: function getLib() {\n        return this.libMethods;\n      }\n    }, {\n      key: \"_get\",\n      value: function _get(path) {\n        return lib.getIn(this.state, path);\n      }\n    }, {\n      key: \"_getContext\",\n      value: function _getContext(path) {\n        return this.contextTree.get(path);\n      }\n    }, {\n      key: \"setContext\",\n      value: function setContext(path, value) {\n        return this.contextTree.set(path, value);\n      }\n    }, {\n      key: \"_hasRun\",\n      value: function _hasRun(count) {\n        var times = this.getPluginRunCount(this.getCurrentPlugin());\n        return times > (count || 0);\n      }\n    }, {\n      key: \"_clone\",\n      value: function _clone(obj) {\n        // For debugging only\n        return JSON.parse(stringify_default()(obj));\n      }\n    }, {\n      key: \"dispatch\",\n      value: function dispatch() {\n        var _this5 = this;\n\n        var that = this;\n        var plugin = this.nextPlugin();\n\n        if (!plugin) {\n          var nextPromise = this.nextPromisedPatch();\n\n          if (nextPromise) {\n            return nextPromise.then(function () {\n              return _this5.dispatch();\n            }).catch(function () {\n              return _this5.dispatch();\n            });\n          } // We're done!\n\n\n          var result = {\n            spec: this.state,\n            errors: this.errors\n          };\n\n          if (this.showDebug) {\n            result.patches = this.allPatches;\n          }\n\n          return promise_default.a.resolve(result);\n        } // Makes sure plugin isn't running an endless loop\n\n\n        that.pluginCount = that.pluginCount || {};\n        that.pluginCount[plugin] = (that.pluginCount[plugin] || 0) + 1;\n\n        if (that.pluginCount[plugin] > HARD_LIMIT) {\n          return promise_default.a.resolve({\n            spec: that.state,\n            errors: that.errors.concat(new Error(\"We've reached a hard limit of \".concat(HARD_LIMIT, \" plugin runs\")))\n          });\n        } // A different plugin runs, wait for all promises to resolve, then retry\n\n\n        if (plugin !== this.currentPlugin && this.promisedPatches.length) {\n          var promises = this.promisedPatches.map(function (p) {\n            return p.value;\n          }); // Waits for all to settle instead of Promise.all which stops on rejection\n\n          return promise_default.a.all(promises.map(function (promise) {\n            return promise.then(Function, Function);\n          })).then(function () {\n            return _this5.dispatch();\n          });\n        } // Ok, run the plugin\n\n\n        return executePlugin();\n\n        function executePlugin() {\n          that.currentPlugin = plugin;\n          var mutations = that.getCurrentMutations();\n          var lastMutationIndex = that.mutations.length - 1;\n\n          try {\n            if (plugin.isGenerator) {\n              var _iteratorNormalCompletion2 = true;\n              var _didIteratorError2 = false;\n              var _iteratorError2 = undefined;\n\n              try {\n                for (var _iterator2 = get_iterator_default()(plugin(mutations, that.getLib())), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n                  var yieldedPatches = _step2.value;\n                  updatePatches(yieldedPatches);\n                }\n              } catch (err) {\n                _didIteratorError2 = true;\n                _iteratorError2 = err;\n              } finally {\n                try {\n                  if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n                    _iterator2.return();\n                  }\n                } finally {\n                  if (_didIteratorError2) {\n                    throw _iteratorError2;\n                  }\n                }\n              }\n            } else {\n              var newPatches = plugin(mutations, that.getLib());\n              updatePatches(newPatches);\n            }\n          } catch (e) {\n            console.error(e); // eslint-disable-line no-console\n\n            updatePatches([object_assign_default()(create_default()(e), {\n              plugin: plugin\n            })]);\n          } finally {\n            that.updatePluginHistory(plugin, {\n              mutationIndex: lastMutationIndex\n            });\n          }\n\n          return that.dispatch();\n        }\n\n        function updatePatches(patches) {\n          if (patches) {\n            patches = lib.fullyNormalizeArray(patches);\n            that.updatePatches(patches, plugin);\n          }\n        }\n      }\n    }]);\n    return SpecMap;\n  }();\n\n  function mapSpec(opts) {\n    return new specmap_SpecMap(opts).dispatch();\n  }\n\n  var plugins = {\n    refs: refs,\n    allOf: all_of,\n    parameters: lib_parameters,\n    properties: lib_properties\n  }; // EXTERNAL MODULE: external \"lodash/isObject\"\n\n  var isObject_ = __webpack_require__(29);\n\n  var isObject_default =\n  /*#__PURE__*/\n  __webpack_require__.n(isObject_); // CONCATENATED MODULE: ./src/helpers.js\n\n\n  var toLower = function toLower(str) {\n    return String.prototype.toLowerCase.call(str);\n  };\n\n  var escapeString = function escapeString(str) {\n    return str.replace(/[^\\w]/gi, '_');\n  }; // Spec version detection\n\n\n  function isOAS3(spec) {\n    var oasVersion = spec.openapi;\n\n    if (!oasVersion) {\n      return false;\n    }\n\n    return startsWith_default()(oasVersion, '3');\n  }\n\n  function isSwagger2(spec) {\n    var swaggerVersion = spec.swagger;\n\n    if (!swaggerVersion) {\n      return false;\n    }\n\n    return startsWith_default()(swaggerVersion, '2');\n  } // Strategy for determining operationId\n\n\n  function opId(operation, pathName) {\n    var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\n    var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        v2OperationIdCompatibilityMode = _ref.v2OperationIdCompatibilityMode;\n\n    if (!operation || typeof_default()(operation) !== 'object') {\n      return null;\n    }\n\n    var idWithoutWhitespace = (operation.operationId || '').replace(/\\s/g, '');\n\n    if (idWithoutWhitespace.length) {\n      return escapeString(operation.operationId);\n    }\n\n    return idFromPathMethod(pathName, method, {\n      v2OperationIdCompatibilityMode: v2OperationIdCompatibilityMode\n    });\n  } // Create a generated operationId from pathName + method\n\n\n  function idFromPathMethod(pathName, method) {\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        v2OperationIdCompatibilityMode = _ref2.v2OperationIdCompatibilityMode;\n\n    if (v2OperationIdCompatibilityMode) {\n      var res = \"\".concat(method.toLowerCase(), \"_\").concat(pathName).replace(/[\\s!@#$%^&*()_+=[{\\]};:<>|./?,\\\\'\"\"-]/g, '_');\n      res = res || \"\".concat(pathName.substring(1), \"_\").concat(method);\n      return res.replace(/((_){2,})/g, '_').replace(/^(_)*/g, '').replace(/([_])*$/g, '');\n    }\n\n    return \"\".concat(toLower(method)).concat(escapeString(pathName));\n  }\n\n  function legacyIdFromPathMethod(pathName, method) {\n    return \"\".concat(toLower(method), \"-\").concat(pathName);\n  } // Get the operation, based on operationId ( just return the object, no inheritence )\n\n\n  function getOperationRaw(spec, id) {\n    if (!spec || !spec.paths) {\n      return null;\n    }\n\n    return findOperation(spec, function (_ref3) {\n      var pathName = _ref3.pathName,\n          method = _ref3.method,\n          operation = _ref3.operation;\n\n      if (!operation || typeof_default()(operation) !== 'object') {\n        return false;\n      }\n\n      var rawOperationId = operation.operationId; // straight from the source\n\n      var operationId = opId(operation, pathName, method);\n      var legacyOperationId = legacyIdFromPathMethod(pathName, method);\n      return [operationId, legacyOperationId, rawOperationId].some(function (val) {\n        return val && val === id;\n      });\n    });\n  } // Will stop iterating over the operations and return the operationObj\n  // as soon as predicate returns true\n\n\n  function findOperation(spec, predicate) {\n    return eachOperation(spec, predicate, true) || null;\n  } // iterate over each operation, and fire a callback with details\n  // `find=true` will stop iterating, when the cb returns truthy\n\n\n  function eachOperation(spec, cb, find) {\n    if (!spec || typeof_default()(spec) !== 'object' || !spec.paths || typeof_default()(spec.paths) !== 'object') {\n      return null;\n    }\n\n    var paths = spec.paths; // Iterate over the spec, collecting operations\n\n    for (var pathName in paths) {\n      for (var method in paths[pathName]) {\n        if (method.toUpperCase() === 'PARAMETERS') {\n          continue;\n        }\n\n        var operation = paths[pathName][method];\n\n        if (!operation || typeof_default()(operation) !== 'object') {\n          continue;\n        }\n\n        var operationObj = {\n          spec: spec,\n          pathName: pathName,\n          method: method.toUpperCase(),\n          operation: operation\n        };\n        var cbValue = cb(operationObj);\n\n        if (find && cbValue) {\n          return operationObj;\n        }\n      }\n    }\n  } // REVIEW: OAS3: identify normalization steps that need changes\n  // ...maybe create `normalizeOAS3`?\n\n\n  function normalizeSwagger(parsedSpec) {\n    var spec = parsedSpec.spec;\n    var paths = spec.paths;\n    var map = {};\n\n    if (!paths || spec.$$normalized) {\n      return parsedSpec;\n    }\n\n    for (var pathName in paths) {\n      var path = paths[pathName];\n\n      if (!isObject_default()(path)) {\n        continue;\n      }\n\n      var pathParameters = path.parameters;\n\n      var _loop = function _loop(method) {\n        var operation = path[method];\n\n        if (!isObject_default()(operation)) {\n          return \"continue\";\n        }\n\n        var oid = opId(operation, pathName, method);\n\n        if (oid) {\n          if (map[oid]) {\n            map[oid].push(operation);\n          } else {\n            map[oid] = [operation];\n          }\n\n          var opList = map[oid];\n\n          if (opList.length > 1) {\n            opList.forEach(function (o, i) {\n              o.__originalOperationId = o.__originalOperationId || o.operationId;\n              o.operationId = \"\".concat(oid).concat(i + 1);\n            });\n          } else if (typeof operation.operationId !== 'undefined') {\n            // Ensure we always add the normalized operation ID if one already exists\n            // ( potentially different, given that we normalize our IDs)\n            // ... _back_ to the spec. Otherwise, they might not line up\n            var obj = opList[0];\n            obj.__originalOperationId = obj.__originalOperationId || operation.operationId;\n            obj.operationId = oid;\n          }\n        }\n\n        if (method !== 'parameters') {\n          // Add inherited consumes, produces, parameters, securities\n          var inheritsList = [];\n          var toBeInherit = {}; // Global-levels\n\n          for (var key in spec) {\n            if (key === 'produces' || key === 'consumes' || key === 'security') {\n              toBeInherit[key] = spec[key];\n              inheritsList.push(toBeInherit);\n            }\n          } // Path-levels\n\n\n          if (pathParameters) {\n            toBeInherit.parameters = pathParameters;\n            inheritsList.push(toBeInherit);\n          }\n\n          if (inheritsList.length) {\n            for (var _i = 0, _inheritsList = inheritsList; _i < _inheritsList.length; _i++) {\n              var inherits = _inheritsList[_i];\n\n              for (var inheritName in inherits) {\n                if (!operation[inheritName]) {\n                  operation[inheritName] = inherits[inheritName];\n                } else if (inheritName === 'parameters') {\n                  var _iteratorNormalCompletion = true;\n                  var _didIteratorError = false;\n                  var _iteratorError = undefined;\n\n                  try {\n                    var _loop2 = function _loop2() {\n                      var param = _step.value;\n                      var exists = operation[inheritName].some(function (opParam) {\n                        return opParam.name && opParam.name === param.name || opParam.$ref && opParam.$ref === param.$ref || opParam.$$ref && opParam.$$ref === param.$$ref || opParam === param;\n                      });\n\n                      if (!exists) {\n                        operation[inheritName].push(param);\n                      }\n                    };\n\n                    for (var _iterator = get_iterator_default()(inherits[inheritName]), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n                      _loop2();\n                    }\n                  } catch (err) {\n                    _didIteratorError = true;\n                    _iteratorError = err;\n                  } finally {\n                    try {\n                      if (!_iteratorNormalCompletion && _iterator.return != null) {\n                        _iterator.return();\n                      }\n                    } finally {\n                      if (_didIteratorError) {\n                        throw _iteratorError;\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      };\n\n      for (var method in path) {\n        var _ret = _loop(method);\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n\n    spec.$$normalized = true;\n    return parsedSpec;\n  } // CONCATENATED MODULE: ./src/resolver.js\n\n\n  function makeFetchJSON(http) {\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var requestInterceptor = opts.requestInterceptor,\n        responseInterceptor = opts.responseInterceptor; // Set credentials with 'http.withCredentials' value\n\n    var credentials = http.withCredentials ? 'include' : 'same-origin';\n    return function (docPath) {\n      return http({\n        url: docPath,\n        loadSpec: true,\n        requestInterceptor: requestInterceptor,\n        responseInterceptor: responseInterceptor,\n        headers: {\n          Accept: ACCEPT_HEADER_VALUE_FOR_DOCUMENTS\n        },\n        credentials: credentials\n      }).then(function (res) {\n        return res.body;\n      });\n    };\n  } // Wipe out the http cache\n\n\n  function resolver_clearCache() {\n    plugins.refs.clearCache();\n  }\n\n  function resolve(obj) {\n    var fetch = obj.fetch,\n        spec = obj.spec,\n        url = obj.url,\n        mode = obj.mode,\n        _obj$allowMetaPatches = obj.allowMetaPatches,\n        allowMetaPatches = _obj$allowMetaPatches === void 0 ? true : _obj$allowMetaPatches,\n        pathDiscriminator = obj.pathDiscriminator,\n        modelPropertyMacro = obj.modelPropertyMacro,\n        parameterMacro = obj.parameterMacro,\n        requestInterceptor = obj.requestInterceptor,\n        responseInterceptor = obj.responseInterceptor,\n        skipNormalization = obj.skipNormalization,\n        useCircularStructures = obj.useCircularStructures;\n    var http = obj.http,\n        baseDoc = obj.baseDoc; // @TODO Swagger-UI uses baseDoc instead of url, this is to allow both\n    // need to fix and pick one.\n\n    baseDoc = baseDoc || url; // Provide a default fetch implementation\n    // TODO fetch should be removed, and http used instead\n\n    http = fetch || http || http_http;\n\n    if (!spec) {\n      return makeFetchJSON(http, {\n        requestInterceptor: requestInterceptor,\n        responseInterceptor: responseInterceptor\n      })(baseDoc).then(doResolve);\n    }\n\n    return doResolve(spec);\n\n    function doResolve(_spec) {\n      if (baseDoc) {\n        plugins.refs.docCache[baseDoc] = _spec;\n      } // Build a json-fetcher ( ie: give it a URL and get json out )\n\n\n      plugins.refs.fetchJSON = makeFetchJSON(http, {\n        requestInterceptor: requestInterceptor,\n        responseInterceptor: responseInterceptor\n      });\n      var plugs = [plugins.refs];\n\n      if (typeof parameterMacro === 'function') {\n        plugs.push(plugins.parameters);\n      }\n\n      if (typeof modelPropertyMacro === 'function') {\n        plugs.push(plugins.properties);\n      }\n\n      if (mode !== 'strict') {\n        plugs.push(plugins.allOf);\n      } // mapSpec is where the hard work happens, see https://github.com/swagger-api/specmap for more details\n\n\n      return mapSpec({\n        spec: _spec,\n        context: {\n          baseDoc: baseDoc\n        },\n        plugins: plugs,\n        allowMetaPatches: allowMetaPatches,\n        // allows adding .meta patches, which include adding `$$ref`s to the spec\n        pathDiscriminator: pathDiscriminator,\n        // for lazy resolution\n        parameterMacro: parameterMacro,\n        modelPropertyMacro: modelPropertyMacro,\n        useCircularStructures: useCircularStructures\n      }).then(skipNormalization ?\n      /*#__PURE__*/\n      function () {\n        var _ref = asyncToGenerator_default()(\n        /*#__PURE__*/\n        regenerator_default.a.mark(function _callee(a) {\n          return regenerator_default.a.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  return _context.abrupt(\"return\", a);\n\n                case 1:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee);\n        }));\n\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }() : normalizeSwagger);\n    }\n  } // EXTERNAL MODULE: external \"lodash/get\"\n\n\n  var get_ = __webpack_require__(16);\n\n  var get_default =\n  /*#__PURE__*/\n  __webpack_require__.n(get_); // CONCATENATED MODULE: ./src/subtree-resolver/index.js\n\n\n  function subtree_resolver_ownKeys(object, enumerableOnly) {\n    var keys = keys_default()(object);\n\n    if (get_own_property_symbols_default.a) {\n      var symbols = get_own_property_symbols_default()(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return get_own_property_descriptor_default()(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function subtree_resolver_objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        subtree_resolver_ownKeys(source, true).forEach(function (key) {\n          defineProperty_default()(target, key, source[key]);\n        });\n      } else if (get_own_property_descriptors_default.a) {\n        define_properties_default()(target, get_own_property_descriptors_default()(source));\n      } else {\n        subtree_resolver_ownKeys(source).forEach(function (key) {\n          define_property_default()(target, key, get_own_property_descriptor_default()(source, key));\n        });\n      }\n    }\n\n    return target;\n  } // The subtree resolver is a higher-level interface that allows you to\n  // get the same result that you would from `Swagger.resolve`, but focuses on\n  // a subtree of your object.\n  //\n  // It makes several assumptions that allow you to think less about what resolve,\n  // specmap, and normalizeSwagger are doing: if this is not suitable for you,\n  // you can emulate `resolveSubtree`'s behavior by talking to the traditional\n  // resolver directly.\n  //\n  // By providing a top-level `obj` and a `path` to resolve within, the subtree\n  // at `path` will be resolved and normalized in the context of your top-level\n  // `obj`. You'll get the resolved subtree you're interest in as a return value\n  // (or, you can use `returnEntireTree` to get everything back).\n  //\n  // This is useful for cases where resolving your entire object is unnecessary\n  // and/or non-performant; we use this interface for lazily resolving operations\n  // and models in Swagger-UI, which allows us to handle larger definitions.\n  //\n  // It's likely that Swagger-Client will rely entirely on lazy resolving in\n  // future versions.\n  //\n  // TODO: move the remarks above into project documentation\n\n\n  function resolveSubtree(_x, _x2) {\n    return _resolveSubtree.apply(this, arguments);\n  }\n\n  function _resolveSubtree() {\n    _resolveSubtree = asyncToGenerator_default()(\n    /*#__PURE__*/\n    regenerator_default.a.mark(function _callee(obj, path) {\n      var opts,\n          returnEntireTree,\n          baseDoc,\n          requestInterceptor,\n          responseInterceptor,\n          parameterMacro,\n          modelPropertyMacro,\n          useCircularStructures,\n          resolveOptions,\n          _normalizeSwagger,\n          normalized,\n          result,\n          _args = arguments;\n\n      return regenerator_default.a.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              opts = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              returnEntireTree = opts.returnEntireTree, baseDoc = opts.baseDoc, requestInterceptor = opts.requestInterceptor, responseInterceptor = opts.responseInterceptor, parameterMacro = opts.parameterMacro, modelPropertyMacro = opts.modelPropertyMacro, useCircularStructures = opts.useCircularStructures;\n              resolveOptions = {\n                pathDiscriminator: path,\n                baseDoc: baseDoc,\n                requestInterceptor: requestInterceptor,\n                responseInterceptor: responseInterceptor,\n                parameterMacro: parameterMacro,\n                modelPropertyMacro: modelPropertyMacro,\n                useCircularStructures: useCircularStructures\n              };\n              _normalizeSwagger = normalizeSwagger({\n                spec: obj\n              }), normalized = _normalizeSwagger.spec;\n              _context.next = 6;\n              return resolve(subtree_resolver_objectSpread({}, resolveOptions, {\n                spec: normalized,\n                allowMetaPatches: true,\n                skipNormalization: true\n              }));\n\n            case 6:\n              result = _context.sent;\n\n              if (!returnEntireTree && is_array_default()(path) && path.length) {\n                result.spec = get_default()(result.spec, path) || null;\n              }\n\n              return _context.abrupt(\"return\", result);\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _resolveSubtree.apply(this, arguments);\n  } // EXTERNAL MODULE: external \"lodash/pick\"\n\n\n  var pick_ = __webpack_require__(38);\n\n  var pick_default =\n  /*#__PURE__*/\n  __webpack_require__.n(pick_); // CONCATENATED MODULE: ./src/interfaces.js\n\n\n  function interfaces_ownKeys(object, enumerableOnly) {\n    var keys = keys_default()(object);\n\n    if (get_own_property_symbols_default.a) {\n      var symbols = get_own_property_symbols_default()(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return get_own_property_descriptor_default()(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function interfaces_objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        interfaces_ownKeys(source, true).forEach(function (key) {\n          defineProperty_default()(target, key, source[key]);\n        });\n      } else if (get_own_property_descriptors_default.a) {\n        define_properties_default()(target, get_own_property_descriptors_default()(source));\n      } else {\n        interfaces_ownKeys(source).forEach(function (key) {\n          define_property_default()(target, key, get_own_property_descriptor_default()(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  var nullFn = function nullFn() {\n    return null;\n  };\n\n  var interfaces_normalizeArray = function normalizeArray(arg) {\n    return is_array_default()(arg) ? arg : [arg];\n  }; // To allow stubbing of functions\n\n\n  var interfaces_self = {\n    mapTagOperations: mapTagOperations,\n    makeExecute: makeExecute // Make an execute, bound to arguments defined in mapTagOperation's callback (cb)\n\n  };\n\n  function makeExecute() {\n    var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return function (_ref) {\n      var pathName = _ref.pathName,\n          method = _ref.method,\n          operationId = _ref.operationId;\n      return function (parameters) {\n        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        return swaggerJs.execute(interfaces_objectSpread({\n          spec: swaggerJs.spec\n        }, pick_default()(swaggerJs, 'requestInterceptor', 'responseInterceptor', 'userFetch'), {\n          pathName: pathName,\n          method: method,\n          parameters: parameters,\n          operationId: operationId\n        }, opts));\n      };\n    };\n  } // Creates an interface with tags+operations = execute\n  // The shape\n  // { apis: { [tag]: { operations: [operation]: { execute }}}}\n  // NOTE: this is mostly for compatibility\n\n\n  function makeApisTagOperationsOperationExecute() {\n    var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {}; // { apis: tag: operations: execute }\n\n    var cb = interfaces_self.makeExecute(swaggerJs);\n    var tagOperations = interfaces_self.mapTagOperations({\n      v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,\n      spec: swaggerJs.spec,\n      cb: cb\n    });\n    var apis = {};\n\n    for (var tag in tagOperations) {\n      apis[tag] = {\n        operations: {}\n      };\n\n      for (var op in tagOperations[tag]) {\n        apis[tag].operations[op] = {\n          execute: tagOperations[tag][op]\n        };\n      }\n    }\n\n    return {\n      apis: apis\n    };\n  } // .apis[tag][operationId]:ExecuteFunction interface\n\n\n  function makeApisTagOperation() {\n    var swaggerJs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var cb = interfaces_self.makeExecute(swaggerJs);\n    return {\n      apis: interfaces_self.mapTagOperations({\n        v2OperationIdCompatibilityMode: swaggerJs.v2OperationIdCompatibilityMode,\n        spec: swaggerJs.spec,\n        cb: cb\n      })\n    };\n  }\n  /**\n     * Iterates over a spec, creating a hash of {[tag]: { [operationId], ... }, ...}\n     * with the value of calling `cb`.\n     *\n     * `spec` is a OAI v2.0 compliant specification object\n     * `cb` is called with ({ spec, operation, path, method })\n     * `defaultTag` will house all non-tagged operations\n     *\n     */\n\n\n  function mapTagOperations(_ref2) {\n    var spec = _ref2.spec,\n        _ref2$cb = _ref2.cb,\n        cb = _ref2$cb === void 0 ? nullFn : _ref2$cb,\n        _ref2$defaultTag = _ref2.defaultTag,\n        defaultTag = _ref2$defaultTag === void 0 ? 'default' : _ref2$defaultTag,\n        v2OperationIdCompatibilityMode = _ref2.v2OperationIdCompatibilityMode;\n    var operationIdCounter = {};\n    var tagOperations = {}; // Will house all tags + operations\n\n    eachOperation(spec, function (_ref3) {\n      var pathName = _ref3.pathName,\n          method = _ref3.method,\n          operation = _ref3.operation;\n      var tags = operation.tags ? interfaces_normalizeArray(operation.tags) : [defaultTag];\n      tags.forEach(function (tag) {\n        if (typeof tag !== 'string') {\n          return;\n        }\n\n        var tagObj = tagOperations[tag] = tagOperations[tag] || {};\n        var id = opId(operation, pathName, method, {\n          v2OperationIdCompatibilityMode: v2OperationIdCompatibilityMode\n        });\n        var cbResult = cb({\n          spec: spec,\n          pathName: pathName,\n          method: method,\n          operation: operation,\n          operationId: id\n        });\n\n        if (operationIdCounter[id]) {\n          operationIdCounter[id]++;\n          tagObj[\"\".concat(id).concat(operationIdCounter[id])] = cbResult;\n        } else if (typeof tagObj[id] !== 'undefined') {\n          // Bump counter ( for this operationId )\n          var originalCounterValue = operationIdCounter[id] || 1;\n          operationIdCounter[id] = originalCounterValue + 1; // Append _x to the operationId\n\n          tagObj[\"\".concat(id).concat(operationIdCounter[id])] = cbResult; // Rename the first operationId\n\n          var temp = tagObj[id];\n          delete tagObj[id];\n          tagObj[\"\".concat(id).concat(originalCounterValue)] = temp;\n        } else {\n          // Assign callback result ( usually a bound function )\n          tagObj[id] = cbResult;\n        }\n      });\n    });\n    return tagOperations;\n  } // EXTERNAL MODULE: external \"@babel/runtime-corejs2/helpers/objectWithoutProperties\"\n\n\n  var objectWithoutProperties_ = __webpack_require__(39);\n\n  var objectWithoutProperties_default =\n  /*#__PURE__*/\n  __webpack_require__.n(objectWithoutProperties_); // EXTERNAL MODULE: external \"lodash/isPlainObject\"\n\n\n  var isPlainObject_ = __webpack_require__(40);\n\n  var isPlainObject_default =\n  /*#__PURE__*/\n  __webpack_require__.n(isPlainObject_); // EXTERNAL MODULE: external \"lodash/isArray\"\n\n\n  var isArray_ = __webpack_require__(41);\n\n  var isArray_default =\n  /*#__PURE__*/\n  __webpack_require__.n(isArray_); // EXTERNAL MODULE: external \"btoa\"\n\n\n  var external_btoa_ = __webpack_require__(19);\n\n  var external_btoa_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_btoa_); // EXTERNAL MODULE: external \"cookie\"\n\n\n  var external_cookie_ = __webpack_require__(42);\n\n  var external_cookie_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_cookie_); // CONCATENATED MODULE: ./src/execute/swagger2/parameter-builders.js\n  // These functions will update the request.\n  // They'll be given {req, value, paramter, spec, operation}.\n\n  /* harmony default export */\n\n\n  var parameter_builders = {\n    body: bodyBuilder,\n    header: headerBuilder,\n    query: queryBuilder,\n    path: pathBuilder,\n    formData: formDataBuilder // Add the body to the request\n\n  };\n\n  function bodyBuilder(_ref) {\n    var req = _ref.req,\n        value = _ref.value;\n    req.body = value;\n  } // Add a form data object.\n\n\n  function formDataBuilder(_ref2) {\n    var req = _ref2.req,\n        value = _ref2.value,\n        parameter = _ref2.parameter;\n\n    if (value || parameter.allowEmptyValue) {\n      req.form = req.form || {};\n      req.form[parameter.name] = {\n        value: value,\n        allowEmptyValue: parameter.allowEmptyValue,\n        collectionFormat: parameter.collectionFormat\n      };\n    }\n  } // Add a header to the request\n\n\n  function headerBuilder(_ref3) {\n    var req = _ref3.req,\n        parameter = _ref3.parameter,\n        value = _ref3.value;\n    req.headers = req.headers || {};\n\n    if (typeof value !== 'undefined') {\n      req.headers[parameter.name] = value;\n    }\n  } // Replace path paramters, with values ( ie: the URL )\n\n\n  function pathBuilder(_ref4) {\n    var req = _ref4.req,\n        value = _ref4.value,\n        parameter = _ref4.parameter;\n    req.url = req.url.split(\"{\".concat(parameter.name, \"}\")).join(encodeURIComponent(value));\n  } // Add a query to the `query` object, which will later be stringified into the URL's search\n\n\n  function queryBuilder(_ref5) {\n    var req = _ref5.req,\n        value = _ref5.value,\n        parameter = _ref5.parameter;\n    req.query = req.query || {};\n\n    if (value === false && parameter.type === 'boolean') {\n      value = 'false';\n    }\n\n    if (value === 0 && ['number', 'integer'].indexOf(parameter.type) > -1) {\n      value = '0';\n    }\n\n    if (value) {\n      req.query[parameter.name] = {\n        collectionFormat: parameter.collectionFormat,\n        value: value\n      };\n    } else if (parameter.allowEmptyValue && value !== undefined) {\n      var paramName = parameter.name;\n      req.query[paramName] = req.query[paramName] || {};\n      req.query[paramName].allowEmptyValue = true;\n    }\n  } // EXTERNAL MODULE: external \"encode-3986\"\n\n\n  var external_encode_3986_ = __webpack_require__(49); // EXTERNAL MODULE: external \"utf8-bytes\"\n\n\n  var external_utf8_bytes_ = __webpack_require__(43);\n\n  var external_utf8_bytes_default =\n  /*#__PURE__*/\n  __webpack_require__.n(external_utf8_bytes_); // EXTERNAL MODULE: external \"utfstring\"\n\n\n  var external_utfstring_ = __webpack_require__(44); // CONCATENATED MODULE: ./src/execute/oas3/style-serializer.js\n\n\n  var isRfc3986Reserved = function isRfc3986Reserved(char) {\n    return ':/?#[]@!$&\\'()*+,;='.indexOf(char) > -1;\n  };\n\n  var isRrc3986Unreserved = function isRrc3986Unreserved(char) {\n    return /^[a-z0-9\\-._~]+$/i.test(char);\n  };\n\n  function encodeDisallowedCharacters(str) {\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        escape = _ref.escape;\n\n    var parse = arguments.length > 2 ? arguments[2] : undefined;\n\n    if (typeof str === 'number') {\n      str = str.toString();\n    }\n\n    if (typeof str !== 'string' || !str.length) {\n      return str;\n    }\n\n    if (!escape) {\n      return str;\n    }\n\n    if (parse) {\n      return JSON.parse(str);\n    }\n\n    return Object(external_utfstring_[\"stringToCharArray\"])(str).map(function (char) {\n      if (isRrc3986Unreserved(char)) {\n        return char;\n      }\n\n      if (isRfc3986Reserved(char) && escape === 'unsafe') {\n        return char;\n      }\n\n      var encoded = (external_utf8_bytes_default()(char) || []).map(function (byte) {\n        return \"0\".concat(byte.toString(16).toUpperCase()).slice(-2);\n      }).map(function (encodedByte) {\n        return \"%\".concat(encodedByte);\n      }).join('');\n      return encoded;\n    }).join('');\n  }\n\n  function stylize(config) {\n    var value = config.value;\n\n    if (is_array_default()(value)) {\n      return encodeArray(config);\n    } else if (typeof_default()(value) === 'object') {\n      return encodeObject(config);\n    }\n\n    return encodePrimitive(config);\n  }\n\n  function encodeArray(_ref2) {\n    var key = _ref2.key,\n        value = _ref2.value,\n        style = _ref2.style,\n        explode = _ref2.explode,\n        escape = _ref2.escape;\n\n    var valueEncoder = function valueEncoder(str) {\n      return encodeDisallowedCharacters(str, {\n        escape: escape\n      });\n    };\n\n    if (style === 'simple') {\n      return value.map(function (val) {\n        return valueEncoder(val);\n      }).join(',');\n    }\n\n    if (style === 'label') {\n      return \".\".concat(value.map(function (val) {\n        return valueEncoder(val);\n      }).join('.'));\n    }\n\n    if (style === 'matrix') {\n      return value.map(function (val) {\n        return valueEncoder(val);\n      }).reduce(function (prev, curr) {\n        if (!prev || explode) {\n          return \"\".concat(prev || '', \";\").concat(key, \"=\").concat(curr);\n        }\n\n        return \"\".concat(prev, \",\").concat(curr);\n      }, '');\n    }\n\n    if (style === 'form') {\n      var after = explode ? \"&\".concat(key, \"=\") : ',';\n      return value.map(function (val) {\n        return valueEncoder(val);\n      }).join(after);\n    }\n\n    if (style === 'spaceDelimited') {\n      var _after = explode ? \"\".concat(key, \"=\") : '';\n\n      return value.map(function (val) {\n        return valueEncoder(val);\n      }).join(\" \".concat(_after));\n    }\n\n    if (style === 'pipeDelimited') {\n      var _after2 = explode ? \"\".concat(key, \"=\") : '';\n\n      return value.map(function (val) {\n        return valueEncoder(val);\n      }).join(\"|\".concat(_after2));\n    }\n  }\n\n  function encodeObject(_ref3) {\n    var key = _ref3.key,\n        value = _ref3.value,\n        style = _ref3.style,\n        explode = _ref3.explode,\n        escape = _ref3.escape;\n\n    var valueEncoder = function valueEncoder(str) {\n      return encodeDisallowedCharacters(str, {\n        escape: escape\n      });\n    };\n\n    var valueKeys = keys_default()(value);\n\n    if (style === 'simple') {\n      return valueKeys.reduce(function (prev, curr) {\n        var val = valueEncoder(value[curr]);\n        var middleChar = explode ? '=' : ',';\n        var prefix = prev ? \"\".concat(prev, \",\") : '';\n        return \"\".concat(prefix).concat(curr).concat(middleChar).concat(val);\n      }, '');\n    }\n\n    if (style === 'label') {\n      return valueKeys.reduce(function (prev, curr) {\n        var val = valueEncoder(value[curr]);\n        var middleChar = explode ? '=' : '.';\n        var prefix = prev ? \"\".concat(prev, \".\") : '.';\n        return \"\".concat(prefix).concat(curr).concat(middleChar).concat(val);\n      }, '');\n    }\n\n    if (style === 'matrix' && explode) {\n      return valueKeys.reduce(function (prev, curr) {\n        var val = valueEncoder(value[curr]);\n        var prefix = prev ? \"\".concat(prev, \";\") : ';';\n        return \"\".concat(prefix).concat(curr, \"=\").concat(val);\n      }, '');\n    }\n\n    if (style === 'matrix') {\n      // no explode\n      return valueKeys.reduce(function (prev, curr) {\n        var val = valueEncoder(value[curr]);\n        var prefix = prev ? \"\".concat(prev, \",\") : \";\".concat(key, \"=\");\n        return \"\".concat(prefix).concat(curr, \",\").concat(val);\n      }, '');\n    }\n\n    if (style === 'form') {\n      return valueKeys.reduce(function (prev, curr) {\n        var val = valueEncoder(value[curr]);\n        var prefix = prev ? \"\".concat(prev).concat(explode ? '&' : ',') : '';\n        var separator = explode ? '=' : ',';\n        return \"\".concat(prefix).concat(curr).concat(separator).concat(val);\n      }, '');\n    }\n  }\n\n  function encodePrimitive(_ref4) {\n    var key = _ref4.key,\n        value = _ref4.value,\n        style = _ref4.style,\n        escape = _ref4.escape;\n\n    var valueEncoder = function valueEncoder(str) {\n      return encodeDisallowedCharacters(str, {\n        escape: escape\n      });\n    };\n\n    if (style === 'simple') {\n      return valueEncoder(value);\n    }\n\n    if (style === 'label') {\n      return \".\".concat(valueEncoder(value));\n    }\n\n    if (style === 'matrix') {\n      return \";\".concat(key, \"=\").concat(valueEncoder(value));\n    }\n\n    if (style === 'form') {\n      return valueEncoder(value);\n    }\n\n    if (style === 'deepObject') {\n      return valueEncoder(value, {}, true);\n    }\n  } // CONCATENATED MODULE: ./src/execute/oas3/content-serializer.js\n\n  /*\n                                                                                Serializer that serializes according to a media type instead of OpenAPI's\n                                                                                `style` + `explode` constructs.\n                                                                              */\n\n\n  function serialize(value, mediaType) {\n    if (mediaType.includes('application/json')) {\n      if (typeof value === 'string') {\n        // Assume the user has a JSON string\n        return value;\n      }\n\n      return stringify_default()(value);\n    }\n\n    return value.toString();\n  } // CONCATENATED MODULE: ./src/execute/oas3/parameter-builders.js\n\n\n  function parameter_builders_path(_ref) {\n    var req = _ref.req,\n        value = _ref.value,\n        parameter = _ref.parameter;\n    var name = parameter.name,\n        style = parameter.style,\n        explode = parameter.explode,\n        content = parameter.content;\n\n    if (content) {\n      var effectiveMediaType = keys_default()(content)[0];\n      req.url = req.url.split(\"{\".concat(name, \"}\")).join(encodeDisallowedCharacters(serialize(value, effectiveMediaType), {\n        escape: true\n      }));\n      return;\n    }\n\n    var styledValue = stylize({\n      key: parameter.name,\n      value: value,\n      style: style || 'simple',\n      explode: explode || false,\n      escape: true\n    });\n    req.url = req.url.split(\"{\".concat(name, \"}\")).join(styledValue);\n  }\n\n  function parameter_builders_query(_ref2) {\n    var req = _ref2.req,\n        value = _ref2.value,\n        parameter = _ref2.parameter;\n    req.query = req.query || {};\n\n    if (parameter.content) {\n      var effectiveMediaType = keys_default()(parameter.content)[0];\n      req.query[parameter.name] = serialize(value, effectiveMediaType);\n      return;\n    }\n\n    if (value === false) {\n      value = 'false';\n    }\n\n    if (value === 0) {\n      value = '0';\n    }\n\n    if (value) {\n      var type = typeof_default()(value);\n\n      if (parameter.style === 'deepObject') {\n        var valueKeys = keys_default()(value);\n        valueKeys.forEach(function (k) {\n          var v = value[k];\n          req.query[\"\".concat(parameter.name, \"[\").concat(k, \"]\")] = {\n            value: stylize({\n              key: k,\n              value: v,\n              style: 'deepObject',\n              escape: parameter.allowReserved ? 'unsafe' : 'reserved'\n            }),\n            skipEncoding: true\n          };\n        });\n      } else if (type === 'object' && !is_array_default()(value) && (parameter.style === 'form' || !parameter.style) && (parameter.explode || parameter.explode === undefined)) {\n        // form explode needs to be handled here,\n        // since we aren't assigning to `req.query[parameter.name]`\n        // like we usually do.\n        var _valueKeys = keys_default()(value);\n\n        _valueKeys.forEach(function (k) {\n          var v = value[k];\n          req.query[k] = {\n            value: stylize({\n              key: k,\n              value: v,\n              style: parameter.style || 'form',\n              escape: parameter.allowReserved ? 'unsafe' : 'reserved'\n            }),\n            skipEncoding: true\n          };\n        });\n      } else {\n        var encodedParamName = encodeURIComponent(parameter.name);\n        req.query[encodedParamName] = {\n          value: stylize({\n            key: encodedParamName,\n            value: value,\n            style: parameter.style || 'form',\n            explode: typeof parameter.explode === 'undefined' ? true : parameter.explode,\n            escape: parameter.allowReserved ? 'unsafe' : 'reserved'\n          }),\n          skipEncoding: true\n        };\n      }\n    } else if (parameter.allowEmptyValue && value !== undefined) {\n      var paramName = parameter.name;\n      req.query[paramName] = req.query[paramName] || {};\n      req.query[paramName].allowEmptyValue = true;\n    }\n  }\n\n  var PARAMETER_HEADER_BLACKLIST = ['accept', 'authorization', 'content-type'];\n\n  function parameter_builders_header(_ref3) {\n    var req = _ref3.req,\n        parameter = _ref3.parameter,\n        value = _ref3.value;\n    req.headers = req.headers || {};\n\n    if (PARAMETER_HEADER_BLACKLIST.indexOf(parameter.name.toLowerCase()) > -1) {\n      return;\n    }\n\n    if (parameter.content) {\n      var effectiveMediaType = keys_default()(parameter.content)[0];\n      req.headers[parameter.name] = serialize(value, effectiveMediaType);\n      return;\n    }\n\n    if (typeof value !== 'undefined') {\n      req.headers[parameter.name] = stylize({\n        key: parameter.name,\n        value: value,\n        style: parameter.style || 'simple',\n        explode: typeof parameter.explode === 'undefined' ? false : parameter.explode,\n        escape: false\n      });\n    }\n  }\n\n  function cookie(_ref4) {\n    var req = _ref4.req,\n        parameter = _ref4.parameter,\n        value = _ref4.value;\n    req.headers = req.headers || {};\n    var type = typeof_default()(value);\n\n    if (parameter.content) {\n      var effectiveMediaType = keys_default()(parameter.content)[0];\n      req.headers.Cookie = \"\".concat(parameter.name, \"=\").concat(serialize(value, effectiveMediaType));\n      return;\n    }\n\n    if (type !== 'undefined') {\n      var prefix = type === 'object' && !is_array_default()(value) && parameter.explode ? '' : \"\".concat(parameter.name, \"=\");\n      req.headers.Cookie = prefix + stylize({\n        key: parameter.name,\n        value: value,\n        escape: false,\n        style: parameter.style || 'form',\n        explode: typeof parameter.explode === 'undefined' ? false : parameter.explode\n      });\n    }\n  } // EXTERNAL MODULE: external \"buffer/\"\n\n\n  var _ = __webpack_require__(30); // CONCATENATED MODULE: ./src/execute/oas3/build-request.js\n  // This function runs after the common function,\n  // `src/execute/index.js#buildRequest`\n\n  /* harmony default export */\n\n\n  var build_request = function (options, req) {\n    var operation = options.operation,\n        requestBody = options.requestBody,\n        securities = options.securities,\n        spec = options.spec,\n        attachContentTypeForEmptyPayload = options.attachContentTypeForEmptyPayload;\n    var requestContentType = options.requestContentType;\n    req = applySecurities({\n      request: req,\n      securities: securities,\n      operation: operation,\n      spec: spec\n    });\n    var requestBodyDef = operation.requestBody || {};\n    var requestBodyMediaTypes = keys_default()(requestBodyDef.content || {});\n    var isExplicitContentTypeValid = requestContentType && requestBodyMediaTypes.indexOf(requestContentType) > -1; // for OAS3: set the Content-Type\n\n    if (requestBody || attachContentTypeForEmptyPayload) {\n      // does the passed requestContentType appear in the requestBody definition?\n      if (requestContentType && isExplicitContentTypeValid) {\n        req.headers['Content-Type'] = requestContentType;\n      } else if (!requestContentType) {\n        var firstMediaType = requestBodyMediaTypes[0];\n\n        if (firstMediaType) {\n          req.headers['Content-Type'] = firstMediaType;\n          requestContentType = firstMediaType;\n        }\n      }\n    } else if (requestContentType && isExplicitContentTypeValid) {\n      req.headers['Content-Type'] = requestContentType;\n    } // for OAS3: add requestBody to request\n\n\n    if (requestBody) {\n      if (requestContentType) {\n        if (requestBodyMediaTypes.indexOf(requestContentType) > -1) {\n          // only attach body if the requestBody has a definition for the\n          // contentType that has been explicitly set\n          if (requestContentType === 'application/x-www-form-urlencoded' || requestContentType.indexOf('multipart/') === 0) {\n            if (typeof_default()(requestBody) === 'object') {\n              req.form = {};\n              keys_default()(requestBody).forEach(function (k) {\n                var val = requestBody[k];\n                var newVal;\n                var isFile;\n\n                if (typeof File !== 'undefined') {\n                  isFile = val instanceof File; // eslint-disable-line no-undef\n                }\n\n                if (typeof Blob !== 'undefined') {\n                  isFile = isFile || val instanceof Blob; // eslint-disable-line no-undef\n                }\n\n                if (typeof _[\"Buffer\"] !== 'undefined') {\n                  isFile = isFile || _[\"Buffer\"].isBuffer(val);\n                }\n\n                if (typeof_default()(val) === 'object' && !isFile) {\n                  if (is_array_default()(val)) {\n                    newVal = val.toString();\n                  } else {\n                    newVal = stringify_default()(val);\n                  }\n                } else {\n                  newVal = val;\n                }\n\n                req.form[k] = {\n                  value: newVal\n                };\n              });\n            } else {\n              req.form = requestBody;\n            }\n          } else {\n            req.body = requestBody;\n          }\n        }\n      } else {\n        req.body = requestBody;\n      }\n    }\n\n    return req;\n  }; // Add security values, to operations - that declare their need on them\n  // Adapted from the Swagger2 implementation\n\n\n  function applySecurities(_ref) {\n    var request = _ref.request,\n        _ref$securities = _ref.securities,\n        securities = _ref$securities === void 0 ? {} : _ref$securities,\n        _ref$operation = _ref.operation,\n        operation = _ref$operation === void 0 ? {} : _ref$operation,\n        spec = _ref.spec;\n    var result = assign_default()({}, request);\n    var _securities$authorize = securities.authorized,\n        authorized = _securities$authorize === void 0 ? {} : _securities$authorize;\n    var security = operation.security || spec.security || [];\n    var isAuthorized = authorized && !!keys_default()(authorized).length;\n    var securityDef = get_default()(spec, ['components', 'securitySchemes']) || {};\n    result.headers = result.headers || {};\n    result.query = result.query || {};\n\n    if (!keys_default()(securities).length || !isAuthorized || !security || is_array_default()(operation.security) && !operation.security.length) {\n      return request;\n    }\n\n    security.forEach(function (securityObj, index) {\n      for (var key in securityObj) {\n        var auth = authorized[key];\n        var schema = securityDef[key];\n\n        if (!auth) {\n          continue;\n        }\n\n        var value = auth.value || auth;\n        var type = schema.type;\n\n        if (auth) {\n          if (type === 'apiKey') {\n            if (schema.in === 'query') {\n              result.query[schema.name] = value;\n            }\n\n            if (schema.in === 'header') {\n              result.headers[schema.name] = value;\n            }\n\n            if (schema.in === 'cookie') {\n              result.cookies[schema.name] = value;\n            }\n          } else if (type === 'http') {\n            if (schema.scheme === 'basic') {\n              var username = value.username,\n                  password = value.password;\n              var encoded = external_btoa_default()(\"\".concat(username, \":\").concat(password));\n              result.headers.Authorization = \"Basic \".concat(encoded);\n            }\n\n            if (schema.scheme === 'bearer') {\n              result.headers.Authorization = \"Bearer \".concat(value);\n            }\n          } else if (type === 'oauth2') {\n            var token = auth.token || {};\n            var tokenName = schema['x-tokenName'] || 'access_token';\n            var tokenValue = token[tokenName];\n            var tokenType = token.token_type;\n\n            if (!tokenType || tokenType.toLowerCase() === 'bearer') {\n              tokenType = 'Bearer';\n            }\n\n            result.headers.Authorization = \"\".concat(tokenType, \" \").concat(tokenValue);\n          }\n        }\n      }\n    });\n    return result;\n  } // CONCATENATED MODULE: ./src/execute/swagger2/build-request.js\n  // This function runs after the common function,\n  // `src/execute/index.js#buildRequest`\n\n  /* harmony default export */\n\n\n  var swagger2_build_request = function (options, req) {\n    var spec = options.spec,\n        operation = options.operation,\n        securities = options.securities,\n        requestContentType = options.requestContentType,\n        attachContentTypeForEmptyPayload = options.attachContentTypeForEmptyPayload; // Add securities, which are applicable\n\n    req = build_request_applySecurities({\n      request: req,\n      securities: securities,\n      operation: operation,\n      spec: spec\n    });\n\n    if (req.body || req.form || attachContentTypeForEmptyPayload) {\n      // all following conditionals are Swagger2 only\n      if (requestContentType) {\n        req.headers['Content-Type'] = requestContentType;\n      } else if (is_array_default()(operation.consumes)) {\n        req.headers['Content-Type'] = operation.consumes[0];\n      } else if (is_array_default()(spec.consumes)) {\n        req.headers['Content-Type'] = spec.consumes[0];\n      } else if (operation.parameters && operation.parameters.filter(function (p) {\n        return p.type === 'file';\n      }).length) {\n        req.headers['Content-Type'] = 'multipart/form-data';\n      } else if (operation.parameters && operation.parameters.filter(function (p) {\n        return p.in === 'formData';\n      }).length) {\n        req.headers['Content-Type'] = 'application/x-www-form-urlencoded';\n      }\n    } else if (requestContentType) {\n      var isBodyParamPresent = operation.parameters && operation.parameters.filter(function (p) {\n        return p.in === 'body';\n      }).length > 0;\n      var isFormDataParamPresent = operation.parameters && operation.parameters.filter(function (p) {\n        return p.in === 'formData';\n      }).length > 0;\n\n      if (isBodyParamPresent || isFormDataParamPresent) {\n        req.headers['Content-Type'] = requestContentType;\n      }\n    }\n\n    return req;\n  }; // Add security values, to operations - that declare their need on them\n\n\n  function build_request_applySecurities(_ref) {\n    var request = _ref.request,\n        _ref$securities = _ref.securities,\n        securities = _ref$securities === void 0 ? {} : _ref$securities,\n        _ref$operation = _ref.operation,\n        operation = _ref$operation === void 0 ? {} : _ref$operation,\n        spec = _ref.spec;\n    var result = assign_default()({}, request);\n    var _securities$authorize = securities.authorized,\n        authorized = _securities$authorize === void 0 ? {} : _securities$authorize,\n        _securities$specSecur = securities.specSecurity,\n        specSecurity = _securities$specSecur === void 0 ? [] : _securities$specSecur;\n    var security = operation.security || specSecurity;\n    var isAuthorized = authorized && !!keys_default()(authorized).length;\n    var securityDef = spec.securityDefinitions;\n    result.headers = result.headers || {};\n    result.query = result.query || {};\n\n    if (!keys_default()(securities).length || !isAuthorized || !security || is_array_default()(operation.security) && !operation.security.length) {\n      return request;\n    }\n\n    security.forEach(function (securityObj, index) {\n      for (var key in securityObj) {\n        var auth = authorized[key];\n\n        if (!auth) {\n          continue;\n        }\n\n        var token = auth.token;\n        var value = auth.value || auth;\n        var schema = securityDef[key];\n        var type = schema.type;\n        var tokenName = schema['x-tokenName'] || 'access_token';\n        var oauthToken = token && token[tokenName];\n        var tokenType = token && token.token_type;\n\n        if (auth) {\n          if (type === 'apiKey') {\n            var inType = schema.in === 'query' ? 'query' : 'headers';\n            result[inType] = result[inType] || {};\n            result[inType][schema.name] = value;\n          } else if (type === 'basic') {\n            if (value.header) {\n              result.headers.authorization = value.header;\n            } else {\n              value.base64 = external_btoa_default()(\"\".concat(value.username, \":\").concat(value.password));\n              result.headers.authorization = \"Basic \".concat(value.base64);\n            }\n          } else if (type === 'oauth2' && oauthToken) {\n            tokenType = !tokenType || tokenType.toLowerCase() === 'bearer' ? 'Bearer' : tokenType;\n            result.headers.authorization = \"\".concat(tokenType, \" \").concat(oauthToken);\n          }\n        }\n      }\n    });\n    return result;\n  } // CONCATENATED MODULE: ./src/execute/index.js\n\n\n  function execute_ownKeys(object, enumerableOnly) {\n    var keys = keys_default()(object);\n\n    if (get_own_property_symbols_default.a) {\n      var symbols = get_own_property_symbols_default()(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return get_own_property_descriptor_default()(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function execute_objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        execute_ownKeys(source, true).forEach(function (key) {\n          defineProperty_default()(target, key, source[key]);\n        });\n      } else if (get_own_property_descriptors_default.a) {\n        define_properties_default()(target, get_own_property_descriptors_default()(source));\n      } else {\n        execute_ownKeys(source).forEach(function (key) {\n          define_property_default()(target, key, get_own_property_descriptor_default()(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  var execute_arrayOrEmpty = function arrayOrEmpty(ar) {\n    return is_array_default()(ar) ? ar : [];\n  };\n\n  var OperationNotFoundError = createErrorType('OperationNotFoundError', function (message, extra, oriError) {\n    this.originalError = oriError;\n    object_assign_default()(this, extra || {});\n  });\n\n  var findParametersWithName = function findParametersWithName(name, parameters) {\n    return parameters.filter(function (p) {\n      return p.name === name;\n    });\n  }; // removes parameters that have duplicate 'in' and 'name' properties\n\n\n  var execute_deduplicateParameters = function deduplicateParameters(parameters) {\n    var paramsMap = {};\n    parameters.forEach(function (p) {\n      if (!paramsMap[p.in]) {\n        paramsMap[p.in] = {};\n      }\n\n      paramsMap[p.in][p.name] = p;\n    });\n    var dedupedParameters = [];\n    keys_default()(paramsMap).forEach(function (i) {\n      keys_default()(paramsMap[i]).forEach(function (p) {\n        dedupedParameters.push(paramsMap[i][p]);\n      });\n    });\n    return dedupedParameters;\n  }; // For stubbing in tests\n\n\n  var execute_self = {\n    buildRequest: buildRequest // Execute request, with the given operationId and parameters\n    // pathName/method or operationId is optional\n\n  };\n\n  function execute(_ref) {\n    var userHttp = _ref.http,\n        fetch = _ref.fetch,\n        spec = _ref.spec,\n        operationId = _ref.operationId,\n        pathName = _ref.pathName,\n        method = _ref.method,\n        parameters = _ref.parameters,\n        securities = _ref.securities,\n        extras = objectWithoutProperties_default()(_ref, [\"http\", \"fetch\", \"spec\", \"operationId\", \"pathName\", \"method\", \"parameters\", \"securities\"]); // Provide default fetch implementation\n\n    var http = userHttp || fetch || http_http; // Default to _our_ http\n\n    if (pathName && method && !operationId) {\n      operationId = legacyIdFromPathMethod(pathName, method);\n    }\n\n    var request = execute_self.buildRequest(execute_objectSpread({\n      spec: spec,\n      operationId: operationId,\n      parameters: parameters,\n      securities: securities,\n      http: http\n    }, extras));\n\n    if (request.body && (isPlainObject_default()(request.body) || isArray_default()(request.body))) {\n      request.body = stringify_default()(request.body);\n    } // Build request and execute it\n\n\n    return http(request);\n  } // Build a request, which can be handled by the `http.js` implementation.\n\n\n  function buildRequest(options) {\n    var spec = options.spec,\n        operationId = options.operationId,\n        securities = options.securities,\n        requestContentType = options.requestContentType,\n        responseContentType = options.responseContentType,\n        scheme = options.scheme,\n        requestInterceptor = options.requestInterceptor,\n        responseInterceptor = options.responseInterceptor,\n        contextUrl = options.contextUrl,\n        userFetch = options.userFetch,\n        requestBody = options.requestBody,\n        server = options.server,\n        serverVariables = options.serverVariables,\n        http = options.http;\n    var parameters = options.parameters,\n        parameterBuilders = options.parameterBuilders;\n    var specIsOAS3 = isOAS3(spec);\n\n    if (!parameterBuilders) {\n      // user did not provide custom parameter builders\n      if (specIsOAS3) {\n        parameterBuilders = oas3_parameter_builders_namespaceObject;\n      } else {\n        parameterBuilders = parameter_builders;\n      }\n    } // Set credentials with 'http.withCredentials' value\n\n\n    var credentials = http && http.withCredentials ? 'include' : 'same-origin'; // Base Template\n\n    var req = {\n      url: '',\n      credentials: credentials,\n      headers: {},\n      cookies: {}\n    };\n\n    if (requestInterceptor) {\n      req.requestInterceptor = requestInterceptor;\n    }\n\n    if (responseInterceptor) {\n      req.responseInterceptor = responseInterceptor;\n    }\n\n    if (userFetch) {\n      req.userFetch = userFetch;\n    }\n\n    var operationRaw = getOperationRaw(spec, operationId);\n\n    if (!operationRaw) {\n      throw new OperationNotFoundError(\"Operation \".concat(operationId, \" not found\"));\n    }\n\n    var _operationRaw$operati = operationRaw.operation,\n        operation = _operationRaw$operati === void 0 ? {} : _operationRaw$operati,\n        method = operationRaw.method,\n        pathName = operationRaw.pathName;\n    req.url += execute_baseUrl({\n      spec: spec,\n      scheme: scheme,\n      contextUrl: contextUrl,\n      server: server,\n      serverVariables: serverVariables,\n      pathName: pathName,\n      method: method\n    }); // Mostly for testing\n\n    if (!operationId) {\n      // Not removing req.cookies causes testing issues and would\n      // change our interface, so we're always sure to remove it.\n      // See the same statement lower down in this function for\n      // more context.\n      delete req.cookies;\n      return req;\n    }\n\n    req.url += pathName; // Have not yet replaced the path parameters\n\n    req.method = \"\".concat(method).toUpperCase();\n    parameters = parameters || {};\n    var path = spec.paths[pathName] || {};\n\n    if (responseContentType) {\n      req.headers.accept = responseContentType;\n    }\n\n    var combinedParameters = execute_deduplicateParameters([].concat(execute_arrayOrEmpty(operation.parameters)) // operation parameters\n    .concat(execute_arrayOrEmpty(path.parameters)) // path parameters\n    ); // REVIEW: OAS3: have any key names or parameter shapes changed?\n    // Any new features that need to be plugged in here?\n    // Add values to request\n\n    combinedParameters.forEach(function (parameter) {\n      var builder = parameterBuilders[parameter.in];\n      var value;\n\n      if (parameter.in === 'body' && parameter.schema && parameter.schema.properties) {\n        value = parameters;\n      }\n\n      value = parameter && parameter.name && parameters[parameter.name];\n\n      if (typeof value === 'undefined') {\n        // check for `name-in` formatted key\n        value = parameter && parameter.name && parameters[\"\".concat(parameter.in, \".\").concat(parameter.name)];\n      } else if (findParametersWithName(parameter.name, combinedParameters).length > 1) {\n        // value came from `parameters[parameter.name]`\n        // check to see if this is an ambiguous parameter\n        // eslint-disable-next-line no-console\n        console.warn(\"Parameter '\".concat(parameter.name, \"' is ambiguous because the defined spec has more than one parameter with the name: '\").concat(parameter.name, \"' and the passed-in parameter values did not define an 'in' value.\"));\n      }\n\n      if (value === null) {\n        return;\n      }\n\n      if (typeof parameter.default !== 'undefined' && typeof value === 'undefined') {\n        value = parameter.default;\n      }\n\n      if (typeof value === 'undefined' && parameter.required && !parameter.allowEmptyValue) {\n        throw new Error(\"Required parameter \".concat(parameter.name, \" is not provided\"));\n      }\n\n      if (specIsOAS3 && parameter.schema && parameter.schema.type === 'object' && typeof value === 'string') {\n        try {\n          value = JSON.parse(value);\n        } catch (e) {\n          throw new Error('Could not parse object parameter value string as JSON');\n        }\n      }\n\n      if (builder) {\n        builder({\n          req: req,\n          parameter: parameter,\n          value: value,\n          operation: operation,\n          spec: spec\n        });\n      }\n    }); // Do version-specific tasks, then return those results.\n\n    var versionSpecificOptions = execute_objectSpread({}, options, {\n      operation: operation\n    });\n\n    if (specIsOAS3) {\n      req = build_request(versionSpecificOptions, req);\n    } else {\n      // If not OAS3, then treat as Swagger2.\n      req = swagger2_build_request(versionSpecificOptions, req);\n    } // If the cookie convenience object exists in our request,\n    // serialize its content and then delete the cookie object.\n\n\n    if (req.cookies && keys_default()(req.cookies).length) {\n      var cookieString = keys_default()(req.cookies).reduce(function (prev, cookieName) {\n        var cookieValue = req.cookies[cookieName];\n        var prefix = prev ? '&' : '';\n        var stringified = external_cookie_default.a.serialize(cookieName, cookieValue);\n        return prev + prefix + stringified;\n      }, '');\n      req.headers.Cookie = cookieString;\n    }\n\n    if (req.cookies) {\n      // even if no cookies were defined, we need to remove\n      // the cookies key from our request, or many many legacy\n      // tests will break.\n      delete req.cookies;\n    } // Will add the query object into the URL, if it exists\n    // ... will also create a FormData instance, if multipart/form-data (eg: a file)\n\n\n    mergeInQueryOrForm(req);\n    return req;\n  }\n\n  var stripNonAlpha = function stripNonAlpha(str) {\n    return str ? str.replace(/\\W/g, '') : null;\n  };\n\n  function execute_baseUrl(obj) {\n    var specIsOAS3 = isOAS3(obj.spec);\n    return specIsOAS3 ? oas3BaseUrl(obj) : swagger2BaseUrl(obj);\n  }\n\n  function oas3BaseUrl(_ref2) {\n    var spec = _ref2.spec,\n        pathName = _ref2.pathName,\n        method = _ref2.method,\n        server = _ref2.server,\n        contextUrl = _ref2.contextUrl,\n        _ref2$serverVariables = _ref2.serverVariables,\n        serverVariables = _ref2$serverVariables === void 0 ? {} : _ref2$serverVariables;\n    var servers = get_default()(spec, ['paths', pathName, (method || '').toLowerCase(), 'servers']) || get_default()(spec, ['paths', pathName, 'servers']) || get_default()(spec, ['servers']);\n    var selectedServerUrl = '';\n    var selectedServerObj = null;\n\n    if (server && servers && servers.length) {\n      var serverUrls = servers.map(function (srv) {\n        return srv.url;\n      });\n\n      if (serverUrls.indexOf(server) > -1) {\n        selectedServerUrl = server;\n        selectedServerObj = servers[serverUrls.indexOf(server)];\n      }\n    }\n\n    if (!selectedServerUrl && servers && servers.length) {\n      // default to the first server if we don't have one by now\n      selectedServerUrl = servers[0].url;\n      selectedServerObj = servers[0];\n    }\n\n    if (selectedServerUrl.indexOf('{') > -1) {\n      // do variable substitution\n      var varNames = getVariableTemplateNames(selectedServerUrl);\n      varNames.forEach(function (vari) {\n        if (selectedServerObj.variables && selectedServerObj.variables[vari]) {\n          // variable is defined in server\n          var variableDefinition = selectedServerObj.variables[vari];\n          var variableValue = serverVariables[vari] || variableDefinition.default;\n          var re = new RegExp(\"{\".concat(vari, \"}\"), 'g');\n          selectedServerUrl = selectedServerUrl.replace(re, variableValue);\n        }\n      });\n    }\n\n    return buildOas3UrlWithContext(selectedServerUrl, contextUrl);\n  }\n\n  function buildOas3UrlWithContext() {\n    var ourUrl = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n    var contextUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n    var parsedUrl = external_url_default.a.parse(ourUrl);\n    var parsedContextUrl = external_url_default.a.parse(contextUrl);\n    var computedScheme = stripNonAlpha(parsedUrl.protocol) || stripNonAlpha(parsedContextUrl.protocol) || '';\n    var computedHost = parsedUrl.host || parsedContextUrl.host;\n    var computedPath = parsedUrl.pathname || '';\n    var res;\n\n    if (computedScheme && computedHost) {\n      res = \"\".concat(computedScheme, \"://\").concat(computedHost + computedPath); // If last character is '/', trim it off\n    } else {\n      res = computedPath;\n    }\n\n    return res[res.length - 1] === '/' ? res.slice(0, -1) : res;\n  }\n\n  function getVariableTemplateNames(str) {\n    var results = [];\n    var re = /{([^}]+)}/g;\n    var text; // eslint-disable-next-line no-cond-assign\n\n    while (text = re.exec(str)) {\n      results.push(text[1]);\n    }\n\n    return results;\n  } // Compose the baseUrl ( scheme + host + basePath )\n\n\n  function swagger2BaseUrl(_ref3) {\n    var spec = _ref3.spec,\n        scheme = _ref3.scheme,\n        _ref3$contextUrl = _ref3.contextUrl,\n        contextUrl = _ref3$contextUrl === void 0 ? '' : _ref3$contextUrl;\n    var parsedContextUrl = external_url_default.a.parse(contextUrl);\n    var firstSchemeInSpec = is_array_default()(spec.schemes) ? spec.schemes[0] : null;\n    var computedScheme = scheme || firstSchemeInSpec || stripNonAlpha(parsedContextUrl.protocol) || 'http';\n    var computedHost = spec.host || parsedContextUrl.host || '';\n    var computedPath = spec.basePath || '';\n    var res;\n\n    if (computedScheme && computedHost) {\n      // we have what we need for an absolute URL\n      res = \"\".concat(computedScheme, \"://\").concat(computedHost + computedPath);\n    } else {\n      // if not, a relative URL will have to do\n      res = computedPath;\n    } // If last character is '/', trim it off\n\n\n    return res[res.length - 1] === '/' ? res.slice(0, -1) : res;\n  } // CONCATENATED MODULE: ./src/index.js\n\n\n  function src_ownKeys(object, enumerableOnly) {\n    var keys = keys_default()(object);\n\n    if (get_own_property_symbols_default.a) {\n      var symbols = get_own_property_symbols_default()(object);\n      if (enumerableOnly) symbols = symbols.filter(function (sym) {\n        return get_own_property_descriptor_default()(object, sym).enumerable;\n      });\n      keys.push.apply(keys, symbols);\n    }\n\n    return keys;\n  }\n\n  function src_objectSpread(target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i] != null ? arguments[i] : {};\n\n      if (i % 2) {\n        src_ownKeys(source, true).forEach(function (key) {\n          defineProperty_default()(target, key, source[key]);\n        });\n      } else if (get_own_property_descriptors_default.a) {\n        define_properties_default()(target, get_own_property_descriptors_default()(source));\n      } else {\n        src_ownKeys(source).forEach(function (key) {\n          define_property_default()(target, key, get_own_property_descriptor_default()(source, key));\n        });\n      }\n    }\n\n    return target;\n  }\n\n  Swagger.http = http_http;\n  Swagger.makeHttp = makeHttp.bind(null, Swagger.http);\n  Swagger.resolve = resolve;\n  Swagger.resolveSubtree = resolveSubtree;\n  Swagger.execute = execute;\n  Swagger.serializeRes = serializeRes;\n  Swagger.serializeHeaders = serializeHeaders;\n  Swagger.clearCache = resolver_clearCache;\n  Swagger.makeApisTagOperation = makeApisTagOperation;\n  Swagger.buildRequest = buildRequest;\n  Swagger.helpers = {\n    opId: opId\n  };\n\n  function Swagger(url) {\n    var _this = this;\n\n    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {}; // Allow url as a separate argument\n\n    if (typeof url === 'string') {\n      opts.url = url;\n    } else {\n      opts = url;\n    }\n\n    if (!(this instanceof Swagger)) {\n      return new Swagger(opts);\n    }\n\n    assign_default()(this, opts);\n    var prom = this.resolve().then(function () {\n      if (!_this.disableInterfaces) {\n        assign_default()(_this, Swagger.makeApisTagOperation(_this));\n      }\n\n      return _this;\n    }); // Expose this instance on the promise that gets returned\n\n    prom.client = this;\n    return prom;\n  }\n\n  Swagger.prototype = {\n    http: http_http,\n    execute: function execute(argHash) {\n      this.applyDefaults();\n      return Swagger.execute(src_objectSpread({\n        spec: this.spec,\n        http: this.http,\n        securities: {\n          authorized: this.authorizations\n        },\n        contextUrl: typeof this.url === 'string' ? this.url : undefined\n      }, argHash));\n    },\n    resolve: function resolve() {\n      var _this2 = this;\n\n      return Swagger.resolve({\n        spec: this.spec,\n        url: this.url,\n        allowMetaPatches: this.allowMetaPatches,\n        useCircularStructures: this.useCircularStructures,\n        requestInterceptor: this.requestInterceptor || null,\n        responseInterceptor: this.responseInterceptor || null\n      }).then(function (obj) {\n        _this2.originalSpec = _this2.spec;\n        _this2.spec = obj.spec;\n        _this2.errors = obj.errors;\n        return _this2;\n      });\n    }\n  };\n\n  Swagger.prototype.applyDefaults = function () {\n    var spec = this.spec;\n    var specUrl = this.url; // TODO: OAS3: support servers here\n\n    if (specUrl && startsWith_default()(specUrl, 'http')) {\n      var parsed = external_url_default.a.parse(specUrl);\n\n      if (!spec.host) {\n        spec.host = parsed.host;\n      }\n\n      if (!spec.schemes) {\n        spec.schemes = [parsed.protocol.replace(':', '')];\n      }\n\n      if (!spec.basePath) {\n        spec.basePath = '/';\n      }\n    }\n  };\n  /* harmony default export */\n\n\n  var src = __webpack_exports__[\"default\"] = Swagger;\n  /***/\n}\n/******/\n])[\"default\"];","map":null,"metadata":{},"sourceType":"script"}