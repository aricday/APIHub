{"ast":null,"code":"var compileSort, hashRows, sha1, shardLength, _;\n\n_ = require('lodash');\nsha1 = require('js-sha1');\ncompileSort = require('./selector').compileSort;\n/*\n\nQuickfind protocol allows sending information about which rows are already present locally to minimize \nnetwork traffic.\n\nProtocal has 3 phases:\n\nencodeRequest: Done on client. Summarize which rows are already present locally by sharding and then hashing _id:_rev|\nencodeResponse: Done on server. Given complete server list and results of encodeRequest, create list of changes, sharded by first two characters of _id\ndecodeResponse: Done on client. Given encoded response and local list, recreate complete list from server.\n\nInteraction of sort, limit and fields:\n\n- fields present: _rev might be missing. Do not use quickfind\n- limit with no sort: This gives unstable results. Do not use quickfind\n- sort: final rows need to be re-sorted. Since fields not present, is possible.\n- no sort, no limit: always sort by _id\n */\n\nshardLength = 2;\n\nexports.encodeRequest = function (clientRows) {\n  var request;\n  clientRows = _.groupBy(clientRows, function (row) {\n    return row._id.substr(0, shardLength);\n  });\n  request = _.mapValues(clientRows, function (rows) {\n    return hashRows(rows);\n  });\n  return request;\n};\n\nexports.encodeResponse = function (serverRows, encodedRequest) {\n  var key, response, value;\n  serverRows = _.groupBy(serverRows, function (row) {\n    return row._id.substr(0, shardLength);\n  });\n\n  for (key in encodedRequest) {\n    value = encodedRequest[key];\n\n    if (!serverRows[key]) {\n      serverRows[key] = [];\n    }\n  }\n\n  response = _.pick(serverRows, function (rows, key) {\n    return hashRows(rows) !== encodedRequest[key];\n  });\n  return response;\n};\n\nexports.decodeResponse = function (encodedResponse, clientRows, sort) {\n  var serverRows;\n  clientRows = _.groupBy(clientRows, function (row) {\n    return row._id.substr(0, shardLength);\n  });\n  serverRows = _.extend(clientRows, encodedResponse);\n  serverRows = _.flatten(_.values(serverRows));\n\n  if (sort) {\n    serverRows.sort(compileSort(sort));\n  } else {\n    serverRows = _.sortBy(serverRows, \"_id\");\n  }\n\n  return serverRows;\n};\n\nhashRows = function hashRows(rows) {\n  var hash, row, _i, _len, _ref;\n\n  hash = sha1.create();\n  _ref = _.sortBy(rows, \"_id\");\n\n  for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n    row = _ref[_i];\n    hash.update(row._id + \":\" + (row._rev || \"\") + \"|\");\n  }\n\n  return hash.hex().substr(0, 20);\n};","map":null,"metadata":{},"sourceType":"script"}