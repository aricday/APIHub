{"ast":null,"code":"var Collection,\n    LocalStorageDb,\n    async,\n    compileSort,\n    processFind,\n    utils,\n    _,\n    __indexOf = [].indexOf || function (item) {\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (i in this && this[i] === item) return i;\n  }\n\n  return -1;\n};\n\n_ = require('lodash');\nasync = require('async');\nutils = require('./utils');\nprocessFind = require('./utils').processFind;\ncompileSort = require('./selector').compileSort;\n\nmodule.exports = LocalStorageDb = function () {\n  function LocalStorageDb(options, success) {\n    this.collections = {};\n\n    if (options && options.namespace && window.localStorage) {\n      this.namespace = options.namespace;\n    }\n\n    if (success) {\n      success(this);\n    }\n  }\n\n  LocalStorageDb.prototype.addCollection = function (name, success, error) {\n    var collection, namespace;\n\n    if (this.namespace) {\n      namespace = this.namespace + \".\" + name;\n    }\n\n    collection = new Collection(name, namespace);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  LocalStorageDb.prototype.removeCollection = function (name, success, error) {\n    var i, key, keyToMatch, keys, _i, _j, _len, _ref;\n\n    if (this.namespace && window.localStorage) {\n      keys = [];\n\n      for (i = _i = 0, _ref = window.localStorage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n        keys.push(window.localStorage.key(i));\n      }\n\n      for (_j = 0, _len = keys.length; _j < _len; _j++) {\n        key = keys[_j];\n        keyToMatch = this.namespace + '.' + name;\n\n        if (key.substring(0, keyToMatch.length) === keyToMatch) {\n          window.localStorage.removeItem(key);\n        }\n      }\n    }\n\n    delete this[name];\n    delete this.collections[name];\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  LocalStorageDb.prototype.getCollectionNames = function () {\n    return _.keys(this.collections);\n  };\n\n  return LocalStorageDb;\n}();\n\nCollection = function () {\n  function Collection(name, namespace) {\n    this.name = name;\n    this.namespace = namespace;\n    this.items = {};\n    this.upserts = {};\n    this.removes = {};\n\n    if (window.localStorage && namespace != null) {\n      this.loadStorage();\n    }\n  }\n\n  Collection.prototype.loadStorage = function () {\n    var base, i, item, key, removeItems, upsertKeys, _i, _j, _len, _ref;\n\n    this.itemNamespace = this.namespace + \"_\";\n\n    for (i = _i = 0, _ref = window.localStorage.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {\n      key = window.localStorage.key(i);\n\n      if (key.substring(0, this.itemNamespace.length) === this.itemNamespace) {\n        item = JSON.parse(window.localStorage[key]);\n        this.items[item._id] = item;\n      }\n    }\n\n    upsertKeys = window.localStorage[this.namespace + \"upserts\"] ? JSON.parse(window.localStorage[this.namespace + \"upserts\"]) : [];\n\n    for (_j = 0, _len = upsertKeys.length; _j < _len; _j++) {\n      key = upsertKeys[_j];\n      this.upserts[key] = {\n        doc: this.items[key]\n      };\n      base = window.localStorage[this.namespace + \"upsertbase_\" + key] ? JSON.parse(window.localStorage[this.namespace + \"upsertbase_\" + key]) : null;\n      this.upserts[key].base = base;\n    }\n\n    removeItems = window.localStorage[this.namespace + \"removes\"] ? JSON.parse(window.localStorage[this.namespace + \"removes\"]) : [];\n    return this.removes = _.object(_.pluck(removeItems, \"_id\"), removeItems);\n  };\n\n  Collection.prototype.find = function (selector, options) {\n    return {\n      fetch: function (_this) {\n        return function (success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      }(this)\n    };\n  };\n\n  Collection.prototype.findOne = function (selector, options, success, error) {\n    var _ref;\n\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n\n    return this.find(selector, options).fetch(function (results) {\n      if (success != null) {\n        return success(results.length > 0 ? results[0] : null);\n      }\n    }, error);\n  };\n\n  Collection.prototype._findFetch = function (selector, options, success, error) {\n    if (success != null) {\n      return success(processFind(_.cloneDeep(_.values(this.items)), selector, options));\n    }\n  };\n\n  Collection.prototype.upsert = function (docs, bases, success, error) {\n    var item, items, _i, _len, _ref;\n\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    items = JSON.parse(JSON.stringify(items));\n\n    for (_i = 0, _len = items.length; _i < _len; _i++) {\n      item = items[_i];\n\n      if (item.base === void 0) {\n        if (this.upserts[item.doc._id]) {\n          item.base = this.upserts[item.doc._id].base;\n        } else {\n          item.base = this.items[item.doc._id] || null;\n        }\n      }\n\n      item = _.cloneDeep(item);\n\n      this._putItem(item.doc);\n\n      this._putUpsert(item);\n    }\n\n    if (success) {\n      return success(docs);\n    }\n  };\n\n  Collection.prototype.remove = function (id, success, error) {\n    if (_.isObject(id)) {\n      this.find(id).fetch(function (_this) {\n        return function (rows) {\n          return async.each(rows, function (row, cb) {\n            return _this.remove(row._id, function () {\n              return cb();\n            }, cb);\n          }, function () {\n            return success();\n          });\n        };\n      }(this), error);\n      return;\n    }\n\n    if (_.has(this.items, id)) {\n      this._putRemove(this.items[id]);\n\n      this._deleteItem(id);\n\n      this._deleteUpsert(id);\n    } else {\n      this._putRemove({\n        _id: id\n      });\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype._putItem = function (doc) {\n    this.items[doc._id] = doc;\n\n    if (this.namespace) {\n      return window.localStorage[this.itemNamespace + doc._id] = JSON.stringify(doc);\n    }\n  };\n\n  Collection.prototype._deleteItem = function (id) {\n    delete this.items[id];\n\n    if (this.namespace) {\n      return window.localStorage.removeItem(this.itemNamespace + id);\n    }\n  };\n\n  Collection.prototype._putUpsert = function (upsert) {\n    this.upserts[upsert.doc._id] = upsert;\n\n    if (this.namespace) {\n      window.localStorage[this.namespace + \"upserts\"] = JSON.stringify(_.keys(this.upserts));\n      return window.localStorage[this.namespace + \"upsertbase_\" + upsert.doc._id] = JSON.stringify(upsert.base);\n    }\n  };\n\n  Collection.prototype._deleteUpsert = function (id) {\n    delete this.upserts[id];\n\n    if (this.namespace) {\n      return window.localStorage[this.namespace + \"upserts\"] = JSON.stringify(_.keys(this.upserts));\n    }\n  };\n\n  Collection.prototype._putRemove = function (doc) {\n    this.removes[doc._id] = doc;\n\n    if (this.namespace) {\n      return window.localStorage[this.namespace + \"removes\"] = JSON.stringify(_.values(this.removes));\n    }\n  };\n\n  Collection.prototype._deleteRemove = function (id) {\n    delete this.removes[id];\n\n    if (this.namespace) {\n      return window.localStorage[this.namespace + \"removes\"] = JSON.stringify(_.values(this.removes));\n    }\n  };\n\n  Collection.prototype.cache = function (docs, selector, options, success, error) {\n    var doc, docsMap, sort, _i, _len, _ref;\n\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n\n      if (options && options.exclude && (_ref = doc._id, __indexOf.call(options.exclude, _ref) >= 0)) {\n        continue;\n      }\n\n      this.cacheOne(doc);\n    }\n\n    docsMap = _.object(_.pluck(docs, \"_id\"), docs);\n\n    if (options.sort) {\n      sort = compileSort(options.sort);\n    }\n\n    return this.find(selector, options).fetch(function (_this) {\n      return function (results) {\n        var result, _j, _len1, _ref1;\n\n        for (_j = 0, _len1 = results.length; _j < _len1; _j++) {\n          result = results[_j];\n\n          if (!docsMap[result._id] && !_.has(_this.upserts, result._id)) {\n            if (options && options.exclude && (_ref1 = result._id, __indexOf.call(options.exclude, _ref1) >= 0)) {\n              continue;\n            }\n\n            if (options.limit && docs.length === options.limit) {\n              if (options.sort && sort(result, _.last(docs)) >= 0) {\n                continue;\n              }\n\n              if (!options.sort) {\n                continue;\n              }\n            }\n\n            _this._deleteItem(result._id);\n          }\n        }\n\n        if (success != null) {\n          return success();\n        }\n      };\n    }(this), error);\n  };\n\n  Collection.prototype.pendingUpserts = function (success) {\n    return success(_.values(this.upserts));\n  };\n\n  Collection.prototype.pendingRemoves = function (success) {\n    return success(_.pluck(this.removes, \"_id\"));\n  };\n\n  Collection.prototype.resolveUpserts = function (upserts, success) {\n    var upsert, _i, _len;\n\n    for (_i = 0, _len = upserts.length; _i < _len; _i++) {\n      upsert = upserts[_i];\n\n      if (this.upserts[upsert.doc._id]) {\n        if (_.isEqual(upsert.doc, this.upserts[upsert.doc._id].doc)) {\n          this._deleteUpsert(upsert.doc._id);\n        } else {\n          this.upserts[upsert.doc._id].base = upsert.doc;\n\n          this._putUpsert(this.upserts[upsert.doc._id]);\n        }\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.resolveRemove = function (id, success) {\n    this._deleteRemove(id);\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.seed = function (docs, success) {\n    var doc, _i, _len;\n\n    if (!_.isArray(docs)) {\n      docs = [docs];\n    }\n\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n\n      if (!_.has(this.items, doc._id) && !_.has(this.removes, doc._id)) {\n        this._putItem(doc);\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.cacheOne = function (doc, success, error) {\n    return this.cacheList([doc], success, error);\n  };\n\n  Collection.prototype.cacheList = function (docs, success) {\n    var doc, existing, _i, _len;\n\n    for (_i = 0, _len = docs.length; _i < _len; _i++) {\n      doc = docs[_i];\n\n      if (!_.has(this.upserts, doc._id) && !_.has(this.removes, doc._id)) {\n        existing = this.items[doc._id];\n\n        if (!existing || !doc._rev || !existing._rev || doc._rev > existing._rev) {\n          this._putItem(doc);\n        }\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncache = function (selector, success, error) {\n    var compiledSelector, item, _i, _len, _ref;\n\n    compiledSelector = utils.compileDocumentSelector(selector);\n    _ref = _.values(this.items);\n\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      item = _ref[_i];\n\n      if (this.upserts[item._id] == null && compiledSelector(item)) {\n        this._deleteItem(item._id);\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  Collection.prototype.uncacheList = function (ids, success, error) {\n    var id, _i, _len;\n\n    for (_i = 0, _len = ids.length; _i < _len; _i++) {\n      id = ids[_i];\n\n      if (this.upserts[id] == null) {\n        this._deleteItem(id);\n      }\n    }\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  return Collection;\n}();","map":null,"metadata":{},"sourceType":"script"}