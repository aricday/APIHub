{"ast":null,"code":"import { useEffect, useRef } from 'react';\nimport { useForm } from 'react-final-form';\nimport { useHistory } from 'react-router-dom';\nimport { useTranslate } from '../i18n';\n/**\n * Display a confirmation dialog if the form has unsaved changes.\n * - If the user confirms, the navigation continues and the changes are lost.\n * - If the user cancels, the navigation is reverted and the changes are kept.\n *\n * We can't use history.block() here because forms have routes, too (for\n * instance TabbedForm), and the confirm dialog would show up when navigating\n * inside the form. So instead of relying on route change detection, we rely\n * on unmount detection. The resulting UI isn't perfect, because when they\n * click the cancel button, users briefly see the page they asked before\n * seeing the form page again. But that's the best we can do.\n *\n * @see history.block()\n */\n\nvar useWarnWhenUnsavedChanges = function useWarnWhenUnsavedChanges(enable) {\n  var form = useForm();\n  var history = useHistory();\n  var translate = useTranslate(); // Keep track of the current location inside the form (e.g. active tab)\n\n  var formLocation = useRef(history.location);\n  useEffect(function () {\n    formLocation.current = history.location;\n  }, [history.location]);\n  useEffect(function () {\n    if (!enable) {\n      window.sessionStorage.removeItem('unsavedChanges');\n      return;\n    } // on mount: apply unsaved changes\n\n\n    var unsavedChanges = JSON.parse(window.sessionStorage.getItem('unsavedChanges'));\n\n    if (unsavedChanges) {\n      Object.keys(unsavedChanges).forEach(function (key) {\n        return form.change(key, unsavedChanges[key]);\n      });\n      window.sessionStorage.removeItem('unsavedChanges');\n    } // on unmount : check and save unsaved changes, then cancel navigation\n\n\n    return function () {\n      var formState = form.getState();\n\n      if (formState.dirty && (!formState.submitSucceeded || formState.submitSucceeded && formState.dirtySinceLastSubmit)) {\n        if (!window.confirm(translate('ra.message.unsaved_changes'))) {\n          var dirtyFields = formState.submitSucceeded ? formState.dirtySinceLastSubmit : formState.dirtyFields;\n          var dirtyFieldValues = Object.keys(dirtyFields).reduce(function (acc, key) {\n            acc[key] = formState.values[key];\n            return acc;\n          }, {});\n          window.sessionStorage.setItem('unsavedChanges', JSON.stringify(dirtyFieldValues));\n          history.push(formLocation.current);\n        }\n      } else {\n        window.sessionStorage.removeItem('unsavedChanges');\n      }\n    };\n  }, [translate]); // eslint-disable-line react-hooks/exhaustive-deps\n};\n\nexport default useWarnWhenUnsavedChanges;","map":null,"metadata":{},"sourceType":"module"}