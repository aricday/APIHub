{"ast":null,"code":"/*\n\nDatabase which caches locally in a localDb but pulls results\nultimately from a RemoteDb\n */\nvar HybridCollection, HybridDb, processFind, utils, _;\n\n_ = require('lodash');\nprocessFind = require('./utils').processFind;\nutils = require('./utils');\n\nmodule.exports = HybridDb = function () {\n  function HybridDb(localDb, remoteDb) {\n    this.localDb = localDb;\n    this.remoteDb = remoteDb;\n    this.collections = {};\n  }\n\n  HybridDb.prototype.addCollection = function (name, options, success, error) {\n    var collection, _ref;\n\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n\n    collection = new HybridCollection(name, this.localDb[name], this.remoteDb[name], options);\n    this[name] = collection;\n    this.collections[name] = collection;\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  HybridDb.prototype.removeCollection = function (name, success, error) {\n    delete this[name];\n    delete this.collections[name];\n\n    if (success != null) {\n      return success();\n    }\n  };\n\n  HybridDb.prototype.upload = function (success, error) {\n    var cols, uploadCols;\n    cols = _.values(this.collections);\n\n    uploadCols = function (cols, success, error) {\n      var col;\n      col = _.first(cols);\n\n      if (col) {\n        return col.upload(function () {\n          return uploadCols(_.rest(cols), success, error);\n        }, function (err) {\n          return error(err);\n        });\n      } else {\n        return success();\n      }\n    };\n\n    return uploadCols(cols, success, error);\n  };\n\n  HybridDb.prototype.getCollectionNames = function () {\n    return _.keys(this.collections);\n  };\n\n  return HybridDb;\n}();\n\nHybridCollection = function () {\n  function HybridCollection(name, localCol, remoteCol, options) {\n    this.name = name;\n    this.localCol = localCol;\n    this.remoteCol = remoteCol;\n    this.options = options || {};\n\n    _.defaults(this.options, {\n      cacheFind: true,\n      cacheFindOne: true,\n      interim: true,\n      useLocalOnRemoteError: true,\n      shortcut: false,\n      timeout: 0,\n      sortUpserts: null\n    });\n  }\n\n  HybridCollection.prototype.find = function (selector, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    return {\n      fetch: function (_this) {\n        return function (success, error) {\n          return _this._findFetch(selector, options, success, error);\n        };\n      }(this)\n    };\n  };\n\n  HybridCollection.prototype.findOne = function (selector, options, success, error) {\n    var step2, _ref;\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (_.isFunction(options)) {\n      _ref = [{}, options, success], options = _ref[0], success = _ref[1], error = _ref[2];\n    }\n\n    _.defaults(options, this.options);\n\n    step2 = function (_this) {\n      return function (localDoc) {\n        var findOptions;\n        findOptions = _.cloneDeep(options);\n        findOptions.interim = false;\n        findOptions.cacheFind = options.cacheFindOne;\n\n        if (selector._id) {\n          findOptions.limit = 1;\n        } else {\n          delete findOptions.limit;\n        }\n\n        return _this.find(selector, findOptions).fetch(function (data) {\n          if (data.length > 0) {\n            if (!_.isEqual(localDoc, data[0])) {\n              return success(data[0]);\n            }\n          } else {\n            return success(null);\n          }\n        }, error);\n      };\n    }(this);\n\n    if (options.interim || options.shortcut) {\n      return this.localCol.findOne(selector, options, function (localDoc) {\n        if (localDoc) {\n          success(_.cloneDeep(localDoc));\n\n          if (options.shortcut) {\n            return;\n          }\n        }\n\n        return step2(localDoc);\n      }, error);\n    } else {\n      return step2();\n    }\n  };\n\n  HybridCollection.prototype._findFetch = function (selector, options, success, error) {\n    _.defaults(options, this.options);\n\n    return this.localCol.pendingUpserts(function (_this) {\n      return function (upserts) {\n        return _this.localCol.pendingRemoves(function (removes) {\n          var localSuccess, step2;\n\n          step2 = function (localData) {\n            var remoteError, remoteOptions, remoteSuccess, timedOut, timer;\n            remoteOptions = _.cloneDeep(options);\n\n            if (options.cacheFind) {\n              delete remoteOptions.fields;\n            }\n\n            remoteOptions.localData = localData;\n            timer = null;\n            timedOut = false;\n\n            remoteSuccess = function (remoteData) {\n              var cacheOptions, cacheSuccess, data, removesMap, upsertsMap;\n\n              if (timer) {\n                clearTimeout(timer);\n              }\n\n              if (timedOut) {\n                if (options.cacheFind) {\n                  _this.localCol.cache(remoteData, selector, options, function () {}, error);\n                }\n\n                return;\n              }\n\n              if (options.cacheFind) {\n                cacheSuccess = function () {\n                  var localSuccess2;\n\n                  localSuccess2 = function (localData2) {\n                    if (!options.interim || !_.isEqual(localData, localData2)) {\n                      return success(localData2);\n                    }\n                  };\n\n                  return _this.localCol.find(selector, options).fetch(localSuccess2, error);\n                };\n\n                cacheOptions = _.extend({}, options, {\n                  exclude: removes.concat(_.map(upserts, function (u) {\n                    return u.doc._id;\n                  }))\n                });\n                return _this.localCol.cache(remoteData, selector, cacheOptions, cacheSuccess, error);\n              } else {\n                data = remoteData;\n\n                if (removes.length > 0) {\n                  removesMap = _.object(_.map(removes, function (id) {\n                    return [id, id];\n                  }));\n                  data = _.filter(remoteData, function (doc) {\n                    return !_.has(removesMap, doc._id);\n                  });\n                }\n\n                if (upserts.length > 0) {\n                  upsertsMap = _.object(_.map(upserts, function (u) {\n                    return u.doc._id;\n                  }), _.map(upserts, function (u) {\n                    return u.doc._id;\n                  }));\n                  data = _.filter(data, function (doc) {\n                    return !_.has(upsertsMap, doc._id);\n                  });\n                  data = data.concat(_.pluck(upserts, \"doc\"));\n                  data = processFind(data, selector, options);\n                }\n\n                if (!options.interim || !_.isEqual(localData, data)) {\n                  return success(data);\n                }\n              }\n            };\n\n            remoteError = function (err) {\n              if (timer) {\n                clearTimeout(timer);\n              }\n\n              if (timedOut) {\n                return;\n              }\n\n              if (!options.interim) {\n                if (options.useLocalOnRemoteError) {\n                  return success(localData);\n                } else {\n                  if (error) {\n                    return error(err);\n                  }\n                }\n              } else {}\n            };\n\n            if (options.timeout) {\n              timer = setTimeout(function () {\n                timer = null;\n                timedOut = true;\n\n                if (!options.interim) {\n                  if (options.useLocalOnRemoteError) {\n                    return _this.localCol.find(selector, options).fetch(success, error);\n                  } else {\n                    if (error) {\n                      return error(new Error(\"Remote timed out\"));\n                    }\n                  }\n                } else {}\n              }, options.timeout);\n            }\n\n            return _this.remoteCol.find(selector, remoteOptions).fetch(remoteSuccess, remoteError);\n          };\n\n          localSuccess = function (localData) {\n            if (options.interim) {\n              success(localData);\n            }\n\n            return step2(localData);\n          };\n\n          return _this.localCol.find(selector, options).fetch(localSuccess, error);\n        }, error);\n      };\n    }(this), error);\n  };\n\n  HybridCollection.prototype.upsert = function (docs, bases, success, error) {\n    var items, _ref;\n\n    _ref = utils.regularizeUpsert(docs, bases, success, error), items = _ref[0], success = _ref[1], error = _ref[2];\n    return this.localCol.upsert(_.pluck(items, \"doc\"), _.pluck(items, \"base\"), function (result) {\n      return typeof success === \"function\" ? success(docs) : void 0;\n    }, error);\n  };\n\n  HybridCollection.prototype.remove = function (id, success, error) {\n    return this.localCol.remove(id, function () {\n      if (success != null) {\n        return success();\n      }\n    }, error);\n  };\n\n  HybridCollection.prototype.upload = function (success, error) {\n    var uploadRemoves, uploadUpserts;\n\n    uploadUpserts = function (_this) {\n      return function (upserts, success, error) {\n        var upsert;\n        upsert = _.first(upserts);\n\n        if (upsert) {\n          return _this.remoteCol.upsert(upsert.doc, upsert.base, function (remoteDoc) {\n            return _this.localCol.resolveUpserts([upsert], function () {\n              if (remoteDoc) {\n                return _this.localCol.cacheOne(remoteDoc, function () {\n                  return uploadUpserts(_.rest(upserts), success, error);\n                }, error);\n              } else {\n                return _this.localCol.remove(upsert.doc._id, function () {\n                  return _this.localCol.resolveRemove(upsert.doc._id, function () {\n                    return uploadUpserts(_.rest(upserts), success, error);\n                  }, error);\n                }, error);\n              }\n            }, error);\n          }, function (err) {\n            if (err.status === 410 || err.status === 403) {\n              return _this.localCol.remove(upsert.doc._id, function () {\n                return _this.localCol.resolveRemove(upsert.doc._id, function () {\n                  if (err.status === 410) {\n                    return uploadUpserts(_.rest(upserts), success, error);\n                  } else {\n                    return error(err);\n                  }\n                }, error);\n              }, error);\n            } else {\n              return error(err);\n            }\n          });\n        } else {\n          return success();\n        }\n      };\n    }(this);\n\n    uploadRemoves = function (_this) {\n      return function (removes, success, error) {\n        var remove;\n        remove = _.first(removes);\n\n        if (remove) {\n          return _this.remoteCol.remove(remove, function () {\n            return _this.localCol.resolveRemove(remove, function () {\n              return uploadRemoves(_.rest(removes), success, error);\n            }, error);\n          }, function (err) {\n            if (err.status === 410 || err.status === 403) {\n              return _this.localCol.resolveRemove(remove, function () {\n                if (err.status === 410) {\n                  return uploadRemoves(_.rest(removes), success, error);\n                } else {\n                  return error(err);\n                }\n              }, error);\n            } else {\n              return error(err);\n            }\n          }, error);\n        } else {\n          return success();\n        }\n      };\n    }(this);\n\n    return this.localCol.pendingUpserts(function (_this) {\n      return function (upserts) {\n        if (_this.options.sortUpserts) {\n          upserts.sort(function (u1, u2) {\n            return _this.options.sortUpserts(u1.doc, u2.doc);\n          });\n        }\n\n        return uploadUpserts(upserts, function () {\n          return _this.localCol.pendingRemoves(function (removes) {\n            return uploadRemoves(removes, success, error);\n          }, error);\n        }, error);\n      };\n    }(this), error);\n  };\n\n  return HybridCollection;\n}();","map":null,"metadata":{},"sourceType":"script"}