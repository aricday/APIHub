{"ast":null,"code":"var _ = require('lodash');\n\nEJSON = {}; // Global!\n\nvar customTypes = {}; // Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --> your object\n// The type you add must have:\n// - A clone() method, so that Meteor can deep-copy it when necessary.\n// - A equals() method, so that Meteor can compare it\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n\nEJSON.addType = function (name, factory) {\n  if (_.has(customTypes, name)) throw new Error(\"Type \" + name + \" already present\");\n  customTypes[name] = factory;\n};\n\nvar builtinConverters = [{\n  // Date\n  matchJSONValue: function (obj) {\n    return _.has(obj, '$date') && _.size(obj) === 1;\n  },\n  matchObject: function (obj) {\n    return obj instanceof Date;\n  },\n  toJSONValue: function (obj) {\n    return {\n      $date: obj.getTime()\n    };\n  },\n  fromJSONValue: function (obj) {\n    return new Date(obj.$date);\n  }\n}, {\n  // Binary\n  matchJSONValue: function (obj) {\n    return _.has(obj, '$binary') && _.size(obj) === 1;\n  },\n  matchObject: function (obj) {\n    return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && _.has(obj, '$Uint8ArrayPolyfill');\n  },\n  toJSONValue: function (obj) {\n    return {\n      $binary: EJSON._base64Encode(obj)\n    };\n  },\n  fromJSONValue: function (obj) {\n    return EJSON._base64Decode(obj.$binary);\n  }\n}, {\n  // Escaping one level\n  matchJSONValue: function (obj) {\n    return _.has(obj, '$escape') && _.size(obj) === 1;\n  },\n  matchObject: function (obj) {\n    if (_.isEmpty(obj) || _.size(obj) > 2) {\n      return false;\n    }\n\n    return _.any(builtinConverters, function (converter) {\n      return converter.matchJSONValue(obj);\n    });\n  },\n  toJSONValue: function (obj) {\n    var newObj = {};\n\n    _.each(obj, function (value, key) {\n      newObj[key] = EJSON.toJSONValue(value);\n    });\n\n    return {\n      $escape: newObj\n    };\n  },\n  fromJSONValue: function (obj) {\n    var newObj = {};\n\n    _.each(obj.$escape, function (value, key) {\n      newObj[key] = EJSON.fromJSONValue(value);\n    });\n\n    return newObj;\n  }\n}, {\n  // Custom\n  matchJSONValue: function (obj) {\n    return _.has(obj, '$type') && _.has(obj, '$value') && _.size(obj) === 2;\n  },\n  matchObject: function (obj) {\n    return EJSON._isCustomType(obj);\n  },\n  toJSONValue: function (obj) {\n    return {\n      $type: obj.typeName(),\n      $value: obj.toJSONValue()\n    };\n  },\n  fromJSONValue: function (obj) {\n    var typeName = obj.$type;\n    var converter = customTypes[typeName];\n    return converter(obj.$value);\n  }\n}];\n\nEJSON._isCustomType = function (obj) {\n  return obj && typeof obj.toJSONValue === 'function' && typeof obj.typeName === 'function' && _.has(customTypes, obj.typeName());\n}; //for both arrays and objects, in-place modification.\n\n\nvar adjustTypesToJSONValue = EJSON._adjustTypesToJSONValue = function (obj) {\n  if (obj === null) return null;\n  var maybeChanged = toJSONValueHelper(obj);\n  if (maybeChanged !== undefined) return maybeChanged;\n\n  _.each(obj, function (value, key) {\n    if (typeof value !== 'object' && value !== undefined) return; // continue\n\n    var changed = toJSONValueHelper(value);\n\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    } // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n\n\n    adjustTypesToJSONValue(value);\n  });\n\n  return obj;\n}; // Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\n\n\nvar toJSONValueHelper = function (item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n\n  return undefined;\n};\n\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n  if (changed !== undefined) return changed;\n\n  if (typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesToJSONValue(item);\n  }\n\n  return item;\n}; //for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n\n\nvar adjustTypesFromJSONValue = EJSON._adjustTypesFromJSONValue = function (obj) {\n  if (obj === null) return null;\n  var maybeChanged = fromJSONValueHelper(obj);\n  if (maybeChanged !== obj) return maybeChanged;\n\n  _.each(obj, function (value, key) {\n    if (typeof value === 'object') {\n      var changed = fromJSONValueHelper(value);\n\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      } // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n\n\n      adjustTypesFromJSONValue(value);\n    }\n  });\n\n  return obj;\n}; // Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\n\n\nvar fromJSONValueHelper = function (value) {\n  if (typeof value === 'object' && value !== null) {\n    if (_.size(value) <= 2 && _.all(value, function (v, k) {\n      return typeof k === 'string' && k.substr(0, 1) === '$';\n    })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n\n  return value;\n};\n\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n\n  if (changed === item && typeof item === 'object') {\n    item = EJSON.clone(item);\n    adjustTypesFromJSONValue(item);\n    return item;\n  } else {\n    return changed;\n  }\n};\n\nEJSON.stringify = function (item) {\n  return JSON.stringify(EJSON.toJSONValue(item));\n};\n\nEJSON.parse = function (item) {\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n\nEJSON.isBinary = function (obj) {\n  return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill;\n};\n\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n  if (a === b) return true;\n  if (!a || !b) // if either one is falsy, they'd have to be === to be equal\n    return false;\n  if (!(typeof a === 'object' && typeof b === 'object')) return false;\n  if (a instanceof Date && b instanceof Date) return a.valueOf() === b.valueOf();\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) return false;\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  if (typeof a.equals === 'function') return a.equals(b, options);\n\n  if (a instanceof Array) {\n    if (!(b instanceof Array)) return false;\n    if (a.length !== b.length) return false;\n\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) return false;\n    }\n\n    return true;\n  } // fall back to structural equality of objects\n\n\n  var ret;\n\n  if (keyOrderSensitive) {\n    var bKeys = [];\n\n    _.each(b, function (val, x) {\n      bKeys.push(x);\n    });\n\n    i = 0;\n    ret = _.all(a, function (val, x) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n\n      if (x !== bKeys[i]) {\n        return false;\n      }\n\n      if (!EJSON.equals(val, b[bKeys[i]], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n    return ret && i === bKeys.length;\n  } else {\n    i = 0;\n    ret = _.all(a, function (val, key) {\n      if (!_.has(b, key)) {\n        return false;\n      }\n\n      if (!EJSON.equals(val, b[key], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n    return ret && _.size(b) === i;\n  }\n};\n\nEJSON.clone = function (v) {\n  var ret;\n  if (typeof v !== \"object\") return v;\n  if (v === null) return null; // null has typeof \"object\"\n\n  if (v instanceof Date) return new Date(v.getTime());\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n\n    return ret;\n  }\n\n  if (_.isArray(v) || _.isArguments(v)) {\n    // For some reason, _.map doesn't work in this context on Opera (weird test\n    // failures).\n    ret = [];\n\n    for (i = 0; i < v.length; i++) ret[i] = EJSON.clone(v[i]);\n\n    return ret;\n  } // handle general user-defined typed Objects if they have a clone method\n\n\n  if (typeof v.clone === 'function') {\n    return v.clone();\n  } // handle other objects\n\n\n  ret = {};\n\n  _.each(v, function (value, key) {\n    ret[key] = EJSON.clone(value);\n  });\n\n  return ret;\n};\n\nmodule.exports = EJSON;","map":null,"metadata":{},"sourceType":"script"}