{"ast":null,"code":"import _regeneratorRuntime from\"/Users/aricday/Projects/APIHub/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _slicedToArray from\"/Users/aricday/Projects/APIHub/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useEffect,useState}from'react';import JSEncrypt from'jsencrypt';import{useApiHub}from'../ApiHubContext';export var defaultEncrypt=function defaultEncrypt(publicKey,data){var encrypter=new JSEncrypt();encrypter.setPublicKey(publicKey);return Promise.resolve(encrypter.encrypt(data));};/**\n * A hook which will fetch the API public key and provide a function to encrypt data.\n * @param {*} encrypt The function to encrypt data.\n * It receives the public key as its first parameter and the dat to encrypt next.\n * It returns a promise resolving to the encrypted data.\n * @returns A tupple with the public key first and the encrypt function next.\n * @example\n *\n * const [publicKey, encrypt] = usePasswordEncryption();\n */export var usePasswordEncryption=function usePasswordEncryption(){var encrypt=arguments.length>0&&arguments[0]!==undefined?arguments[0]:defaultEncrypt;var _useApiHub=useApiHub(),urlWithTenant=_useApiHub.urlWithTenant;var _useState=useState(),_useState2=_slicedToArray(_useState,2),publicKey=_useState2[0],setPublicKey=_useState2[1];useEffect(function(){fetchPublicKey(urlWithTenant).then(setPublicKey)[\"catch\"](console.error);},[urlWithTenant]);var encryptData=function encryptData(data){var encryptedData;return _regeneratorRuntime.async(function encryptData$(_context){while(1){switch(_context.prev=_context.next){case 0:if(publicKey){_context.next=2;break;}return _context.abrupt(\"return\",data);case 2:_context.next=4;return _regeneratorRuntime.awrap(encrypt(publicKey,data));case 4:encryptedData=_context.sent;return _context.abrupt(\"return\",encryptedData);case 6:case\"end\":return _context.stop();}}});};return[publicKey,encryptData];};var fetchPublicKey=function fetchPublicKey(apiBaseUrl){var response,data;return _regeneratorRuntime.async(function fetchPublicKey$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return _regeneratorRuntime.awrap(fetch(\"\".concat(apiBaseUrl,\"/authenticate/getPublicKey\")));case 2:response=_context2.sent;if(!(response.status<200||response.status>=300)){_context2.next=5;break;}return _context2.abrupt(\"return\",undefined);case 5:_context2.next=7;return _regeneratorRuntime.awrap(response.json());case 7:data=_context2.sent;return _context2.abrupt(\"return\",data.publicKey);case 9:case\"end\":return _context2.stop();}}});};","map":{"version":3,"sources":["/Users/aricday/Projects/APIHub/packages/layer7-apihub/src/authentication/usePasswordEncryption.js"],"names":["useEffect","useState","JSEncrypt","useApiHub","defaultEncrypt","publicKey","data","encrypter","setPublicKey","Promise","resolve","encrypt","usePasswordEncryption","urlWithTenant","fetchPublicKey","then","console","error","encryptData","encryptedData","apiBaseUrl","fetch","response","status","undefined","json"],"mappings":"iSAAA,OAASA,SAAT,CAAoBC,QAApB,KAAoC,OAApC,CACA,MAAOC,CAAAA,SAAP,KAAsB,WAAtB,CACA,OAASC,SAAT,KAA0B,kBAA1B,CAEA,MAAO,IAAMC,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAACC,SAAD,CAAYC,IAAZ,CAAqB,CAC/C,GAAMC,CAAAA,SAAS,CAAG,GAAIL,CAAAA,SAAJ,EAAlB,CACAK,SAAS,CAACC,YAAV,CAAuBH,SAAvB,EACA,MAAOI,CAAAA,OAAO,CAACC,OAAR,CAAgBH,SAAS,CAACI,OAAV,CAAkBL,IAAlB,CAAhB,CAAP,CACH,CAJM,CAMP;;;;;;;;;GAUA,MAAO,IAAMM,CAAAA,qBAAqB,CAAG,QAAxBA,CAAAA,qBAAwB,EAA8B,IAA7BD,CAAAA,OAA6B,2DAAnBP,cAAmB,gBACrCD,SAAS,EAD4B,CACvDU,aADuD,YACvDA,aADuD,eAE7BZ,QAAQ,EAFqB,wCAExDI,SAFwD,eAE7CG,YAF6C,eAI/DR,SAAS,CAAC,UAAM,CACZc,cAAc,CAACD,aAAD,CAAd,CACKE,IADL,CACUP,YADV,WAEWQ,OAAO,CAACC,KAFnB,EAGH,CAJQ,CAIN,CAACJ,aAAD,CAJM,CAAT,CAMA,GAAMK,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAAMZ,IAAN,4IACXD,SADW,yDAELC,IAFK,0DAKYK,OAAO,CAACN,SAAD,CAAYC,IAAZ,CALnB,SAKVa,aALU,+CAMTA,aANS,gDAApB,CASA,MAAO,CAACd,SAAD,CAAYa,WAAZ,CAAP,CACH,CApBM,CAsBP,GAAMJ,CAAAA,cAAc,CAAG,QAAjBA,CAAAA,cAAiB,CAAMM,UAAN,iMACIC,KAAK,WAAID,UAAJ,+BADT,SACbE,QADa,qBAGfA,QAAQ,CAACC,MAAT,CAAkB,GAAlB,EAAyBD,QAAQ,CAACC,MAAT,EAAmB,GAH7B,4DAIRC,SAJQ,2DAOAF,QAAQ,CAACG,IAAT,EAPA,SAObnB,IAPa,iDASZA,IAAI,CAACD,SATO,iDAAvB","sourcesContent":["import { useEffect, useState } from 'react';\nimport JSEncrypt from 'jsencrypt';\nimport { useApiHub } from '../ApiHubContext';\n\nexport const defaultEncrypt = (publicKey, data) => {\n    const encrypter = new JSEncrypt();\n    encrypter.setPublicKey(publicKey);\n    return Promise.resolve(encrypter.encrypt(data));\n};\n\n/**\n * A hook which will fetch the API public key and provide a function to encrypt data.\n * @param {*} encrypt The function to encrypt data.\n * It receives the public key as its first parameter and the dat to encrypt next.\n * It returns a promise resolving to the encrypted data.\n * @returns A tupple with the public key first and the encrypt function next.\n * @example\n *\n * const [publicKey, encrypt] = usePasswordEncryption();\n */\nexport const usePasswordEncryption = (encrypt = defaultEncrypt) => {\n    const { urlWithTenant } = useApiHub();\n    const [publicKey, setPublicKey] = useState();\n\n    useEffect(() => {\n        fetchPublicKey(urlWithTenant)\n            .then(setPublicKey)\n            .catch(console.error);\n    }, [urlWithTenant]);\n\n    const encryptData = async data => {\n        if (!publicKey) {\n            return data;\n        }\n\n        const encryptedData = await encrypt(publicKey, data);\n        return encryptedData;\n    };\n\n    return [publicKey, encryptData];\n};\n\nconst fetchPublicKey = async apiBaseUrl => {\n    const response = await fetch(`${apiBaseUrl}/authenticate/getPublicKey`);\n\n    if (response.status < 200 || response.status >= 300) {\n        return undefined;\n    }\n\n    const data = await response.json();\n\n    return data.publicKey;\n};\n"]},"metadata":{},"sourceType":"module"}